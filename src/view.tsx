import React, { Dispatch, memo, SetStateAction, useEffect, useState } from "react";
import { VIEW_CONNECT_STORE_KEY, RESY_ID } from "./static";
import { mapToObject, storeErrorHandle } from "./utils";
import {
  getLatestStateMap, stateRefByProxyHandle,
  viewStoresStateUpdateHandle, viewStoresToLatestState,
} from "./reduce";
import type {
  PrimitiveState, StoreViewMapType, StoreViewMapValue, MapStateToProps, Store, PS, Unsubscribe,
  Stores, ObjectMapType, ViewStateMapType, ValueOf, MapType, ObjectType,
} from "./model";

/**
 * 自动memo与SCU的高阶HOC
 * @description 它会自动化规避组件额外多余的re-render
 *
 * @return (stores?:Store<S>|Stores<S>)=>React.MemoExoticComponent<(props:P)=>JSX.Element>
 *          ➡ 👉 @param stores: store or stores`s store is generated by createStore();
 * @param Comp 被包裹的组件
 * @param equal 是否相等自定义函数
 */
export function view<P extends PrimitiveState = {}, S extends PrimitiveState = {}>(
  // any用于兼容某些HOC导致的类型不合一问题，比如withRouter(低版本的react-router还是存在该HOC)
  // tslint:disable-next-line:variable-name
  Comp: React.ComponentType<MapStateToProps<S, P> | any>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  return (stores?: Store<S> | Stores<S>) => memo((props: P) => {
    /** 需要将innerUseStateMapSet与stateMap放在内部执行，这样每次更新的时候可以得到最新的数据引用与数据stateMap */
    // 引用数据的代理Set（默认无store）
    let innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>> = new Set();
    
    /**
     * @description 给state数据做一个代理，从而让其知晓Comp组件内部使用了哪些数据！
     * 恰巧由于这里的proxy代理，导致在挂载属性数据的时候不能使用扩展运算符，
     * 扩展运算符...会读取所有的属性数据，导致内部关联使用数据属性失去准确性
     * 所以只能挂载到一个集中的属性上，这里选择来props的state属性上
     *
     * be careful: state是一个proxy，这里如果外部数据对象将state作为原型链继承将是无效继承
     */
    const [state, setState] = useState<S | { [key in keyof Stores<S>]: S }>(() => {
      // 需要使用getState获取store内部的即时最新数据值（默认无store）
      let stateMap: ViewStateMapType<S> = new Map() as MapType<S>;
      
      /**
       * 如果是有store的情况则可以通过props.state的方式进行数据渲染及操作
       * 且props.state的方式兼容于函数组件与class组件
       * 但是如果是在class组件中则必须使用props.state的方式
       * 而函数组件则两种方式都可以
       */
      // 先行初始化执行逻辑，并且每次生命周期中只同步执行一次
      if (stores) {
        // 单个Store
        if ((stores as Store<S>)[RESY_ID as keyof S]) {
          (
            (
              (stores as Store<S>)?.[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
            )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
          )?.();
          
          stateMap = getLatestStateMap(stores as Store<S>);
        } else {
          // 多个store
          innerUseStateMapSet = new Map<keyof Stores<S>, Set<keyof S>>();
          (Object.keys(stores) as (keyof Stores<S>)[]).forEach(storesKey => {
            const storeItem = (stores as Stores<S>)[storesKey] as Store<S>;
            
            (
              (
                storeItem?.[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
              )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
            )?.();
            
            (stateMap as ObjectMapType<S>)[storesKey] = getLatestStateMap(storeItem);
            
            (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).set(storesKey, new Set<keyof S>());
          });
        }
      }
      
      // 单store 或 无store
      if (!stores || (stores as Store<S>)[RESY_ID as keyof S]) {
        return stateRefByProxyHandle(stateMap as MapType<S>, innerUseStateMapSet as Set<keyof S>);
      }
      // 多store
      const stateTemp = {} as ObjectType<S>;
      Object.keys(stateMap).forEach((stateMapKey: keyof S) => {
        stateTemp[stateMapKey] = stateRefByProxyHandle<ValueOf<S>>(
          (stateMap as ObjectMapType<S>)[stateMapKey],
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).get(stateMapKey) as Set<keyof S>,
        );
      });
      return stateTemp;
    });
    
    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(() => mountedHandle(innerUseStateMapSet, state, setState, props, stores, equal), []);
    
    return <Comp {...props} state={state}/>;
  }, equal ? (prevProps: P, nextProps: P) => {
    // props与state的变化可能存在同时变化的情况，但不影响equal的执行
    const latestState = stores
      ? (stores as Store<S>)[RESY_ID as keyof S]
        ? mapToObject(getLatestStateMap(stores as Store<S>))
        : viewStoresToLatestState(stores)
      : ({} as S);
    return equal(
      { props: nextProps, state: latestState },
      { props: prevProps, state: latestState },
    );
  } : undefined);
}

// 组件加载完成后的处理
function mountedHandle<S extends PrimitiveState, P extends PrimitiveState = {}>(
  innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>>,
  state: S | { [key in keyof Stores<S>]: S },
  setState: Dispatch<SetStateAction<S | { [key in keyof Stores<S>]: S }>>,
  props: P,
  stores?: Store<S> | Stores<S>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  if (!stores) return;
  
  // 因为useEffect是异步的，所以后续访问 innerUseStateMapSet 时会有数据而不是空
  const viewConnectStoreSet = new Set<Unsubscribe>();
  
  let unsubscribe: Unsubscribe | Unsubscribe[];
  // 单store
  if ((stores as Store<S>)[RESY_ID as keyof S]) {
    unsubscribe = handleStoreSubscribe(
      stores as Store<S>,
      innerUseStateMapSet,
      viewConnectStoreSet,
      state,
      setState,
      props,
      equal,
      true,
    );
  } else {
    unsubscribe = [];
    Object.keys(stores).forEach(storesKey => {
      (unsubscribe as Unsubscribe[]).push(handleStoreSubscribe(
        stores[storesKey],
        innerUseStateMapSet,
        viewConnectStoreSet,
        state,
        setState,
        props,
        equal,
        false,
        storesKey,
      ));
    });
  }
  
  return () => {
    typeof unsubscribe === "function" ? unsubscribe() : unsubscribe.forEach(item => item());
    viewConnectStoreSet.forEach(unsubscribe => unsubscribe());
    innerUseStateMapSet.clear();
  };
}

// 处理单个/多个store的数据订阅监听
function handleStoreSubscribe<S extends PrimitiveState, P extends PrimitiveState = {}>(
  store: Store<S>,
  innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>>,
  viewConnectStoreSet: Set<Unsubscribe>,
  state: S | { [key in keyof Stores<S>]: S },
  setState: Dispatch<SetStateAction<S | { [key in keyof Stores<S>]: S }>>,
  props: P,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
  singleStore?: boolean,
  storesKeyTemp?: keyof Stores<S>,
) {
  // 在mounted进行一次的store校验
  storeErrorHandle(store, "view");
  
  if (singleStore) {
    innerUseStateMapSet.forEach(() => {
      // 将view关联到store内部的storeStateRefSet，进行数据生命周期的同步
      viewConnectStoreSet.add(
        (
          (
            store[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
          ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
        )()
      );
    });
    
    // 刚好巧妙的与resy的订阅监听subscribe结合起来，形成一个reactive更新的包裹容器
    return store.subscribe((
      effectState,
      nextState,
      prevState,
    ) => {
      const effectStateFields = Object.keys(effectState);
      
      if (
        // Comp组件内部使用到的数据属性字段数组，放在触发执行保持内部引用数据最新化
        Array.from(innerUseStateMapSet as Set<keyof S>).some(key => effectStateFields.includes(key as string))
        && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
      ) {
        setState(stateRefByProxyHandle(new Map(Object.entries(nextState)), innerUseStateMapSet as Set<keyof S>));
      }
    });
  } else {
    (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).forEach((
      _,
      storesKey,
      map,
    ) => {
      (map.get(storesKey) as Set<keyof S>).forEach(() => {
        // 将view关联到每一个store内部的storeStateRefSet，进行数据生命周期的同步
        viewConnectStoreSet.add(
          (
            (
              store[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
            ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
          )()
        );
      });
    });
    
    return store.subscribe((
      effectState,
      nextState,
      prevState,
    ) => {
      const effectStateFields = Object.keys(effectState);
      const innerUseStateSet = (
        innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>
      ).get(storesKeyTemp as keyof Stores<S>) as Set<keyof S>;
      
      if (
        // Comp组件内部使用到的数据属性字段数组，放在触发执行保持内部引用数据最新化
        Array.from(innerUseStateSet).some(key => effectStateFields.includes(key as string))
        && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
      ) {
        setState(viewStoresStateUpdateHandle(state, innerUseStateSet, nextState, storesKeyTemp));
      }
    });
  }
}
