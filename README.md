<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Native、SSR、Mini WeChat Apps (such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=blue&style=flat-square)](https://github.com/lsbFlying/resy/actions/workflows/test.yml)
[![Codecov](https://img.shields.io/codecov/c/github/lsbFlying/resy?style=flat-square)](https://codecov.io/gh/lsbFlying/resy)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)
</div>

---

##### releases what's Changed
<details>
<summary>changed logs</summary>

🌟`v5.0.0`：<br/>
1、优化了代码，修复了setState的混用场景的批量触发的订阅变化的数据不完备的bug；<br/>
2、修复了createStore作为私有化数据状态使用的的方式的bug；<br/>
3、新增了 "useRocketState" 钩子简化了状态数据私有化的使用方式；<br/>
4、新增了 "syncUpdate" 同步更新api；

🌟`v4.0.5`：<br/>
完善了setState与直接更新的所有混用场景的合并更新

🌟`v4.0.4`：<br/>
1、修复了直接更新在useEffect中相近的下一轮的更新批次中无法得到更新的bug<br/>
2、优化直接更新方式的add函数的执行<br/>
3、优化了直接更新与setState批量更新混用的场景中的合并更新

🌟`v4.0.3`：<br/>
1、修复了view的deepEqual的对比props的逻辑，避免了组件因为props的引用地址的不同产生额外更新渲染的问题；<br/>
2、完善优化了数据订阅监听"subscribe"代码的执行性能。

🌟`v4.0.2`：<br/>
1、修复了view的getDerivedStateFromProps的逻辑数据为空的处理bug；<br/>
2、修复了view包裹的组件内部可能的复杂引用逻辑导致的数据引用字段的获取缺失，进而导致的更新失效的bug；

🌟`v4.0.1`：修复了useStore的hookInitialState初始化hook参数的使用时，
可能存在的多次设置对应的key值问题

🌟`v4.0.0`：resy自v4.0.0版本开始，正式进入稳定发展的开始，api已完成命名不会轻易变更，
同时代码也趋于稳定与强化，欢迎大家使用🌟🌟🌟🌟🌟

</details>

### Features
- 😎 Create simple
- 😎 Sharing freedom
- 😎 Easy to use
- 😎 Can be global or local
- 😎 Fine-grained update
- 😎 Automate SCU and memo processing

### Install
```sh
npm i resy

# yarn add resy
```

### overview
resy requires the version of react v >= 16.8, resy has seven API, which are:
- createStore：Create a store container for global state
- useStore：Use state from the store container generated by createStore
- setState：Update data
- syncUpdate：Synchronously update data
- useRocketState：Simplified version of useState
- subscribe：Subscribe for changes in store data generated by createStore
- view：Help components to automatically process SCU and memo

### createStore
```tsx
import { createStore, useStore } from "resy";

type StateType = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};

// The generated store can be shared globally
const store = createStore<StateType>(
  {
    count: 0,
    text: "hello",
    testObj: { name: "Jack" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  // Generally, the options configuration item does not need to be configured
  {
    /**
     * @default true
     * @description
     * if value is true, reset state to initialState after components unmounted
     * or false not reset state to initialState.
     * Unless you refresh the browser or device intentionally,
     * otherwise it will keep the data status.
     *
     * So, if situation for example login or theme,
     * we can set unmountReset is false.
     */
    unmountReset: true,
    /**
     * @description It is generally unnecessary to set it,
     * It is a configuration item used internally in the code,
     * and will be introduced in detail in combination with "useRocketState"
     */
    privatization: false,
  },
);
```

### useStore
```tsx
function App() {
  /**
   * @description You can think of it as useState, but not exactly.
   * It is used to drive component updates re-render.
   * 
   * If you directly deconstruct the store for example: 
   * const { count } = store;
   * Only simple data will be obtained, which has no update effect
   */
  const {
    count, text, testObj: { name }, testArr, testFun, inputValue,
  } = useStore(store);
  
  // Or: const state = useStore(store);
  // state.count; ...eg
  
  function btn2() {
    // Updates can be assigned directly (simple update method)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chained updates are not allowed,
     * because resy only maps the data attributes of the first layer
     * Currently, there is no in-depth recursive agent for performance reasons.
     * The following update method is invalid
     */
    // store.testObj.name = "Jack";
    store.testObj = { name: "Jack" }; // Effective update
    // Similarly, arrays are not allowed to update data by directly changing the index value,
    // and the following update method is invalid
    // store.testArr[0] = { age: 7 };
    store.testArr = [{age: 7}]; // Effective update
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>btn1</button>
      <br/>
      {testArr.map(item => `Age：${item}`)}<br/>
      <button onClick={btn2}>btn2</button>
    </>
  );
}
```

### useStore ———— with hooks value
```tsx
import { createStore, useStore } from "resy";
import { Form } from "antd";
import { FormInstance } from "antd/es/form";

const store = createStore<{
  form?: FormInstance<{ sortNumber: number }>;
}>();

function App() {
  /**
   * If some data is generated by some hooks
   * At this point, you need to use the second parameter of useStore: hookInitialState
   *
   * If you code with typescript, the type or interface of data needs to be non-essential when defined.
   * eg: { form?: FormInstance<{ sortNumber: number }>; }
   */
  const { form } = useStore(
    store,
    {
      form: Form.useForm<{ sortNumber: number }>()[0],
    },
  );
  
  function addClick() {
    form?.setFieldsValue({
      sortNumber: 9999,
    });
  }
  
  return (
    <Form form={form} components={false}>
      <Form.Item name="sortNumber">
        <InputNumber/>
      </Form.Item>
      <br/>
      <button onClick={addClick}>btn</button>
    </Form>
  );
}
```

### setState
```tsx
function App() {
  const { count, text } = useStore(store);
  
  function btnClick() {
    /**
     * A: setState and a single direct update are asynchronous,
     * the callback function of setState can obtain the latest data.
     * setState uses objects as the data update method to have more robust coding capabilities.
     * The update method of function input parameters makes setState more robust.
     *
     * B: Resy has the effect of automatic batch updating.
     * It can make up for the effect of batch updating of versions below react v18
     * for promises or setTimeout that cannot be managed by react
     *
     * C: In most cases, setState and a single direct update are asynchronous,
     * but in some extreme cases, a batch of updates in the middle will become synchronous.
     * This is to ensure the smoothness and coordination of updates.
     */
    // @example A
    store.setState({
      count: count + 1,
      text: "BNM",
    }, (nextState) => {
      // nextState：The latest data
      console.log(nextState.count, nextState.text);
      // Or at this time, you can read store to get the latest data.
      // console.log(store.count, store.text);
    });
    // The B way can write circular updates in the callback function
    // to facilitate the handling of some more complex business logic.
    // @example B
    // store.setState(() => {
    //   store.count++;
    //   store.text = "B-Way-setState-with-function";
    // }, (nextState) => {
    //   console.log(nextState.count, nextState.text);
    // });
  }
  
  return (
    <>
      <div>{count}</div>
      <div>{text}</div>
      <button onClick={btnClick}>btn</button>
    </>
  );
}
```

### syncUpdate
```tsx
function App() {
  const { inputValue } = useStore(store);
  
  function inputChange(event: React.ChangeEvent<HTMLInputElement>) {
    /**
      * todo：The update of this controlled input/textarea needs to be updated synchronously,
      * otherwise, due to asynchronous updates such as "store.setState" or "store[key] = newValue",
      * it will cause input/textarea unable to input characters in languages other than English.
      * todo："syncUpdate" is a helpless solution to the conflict between
      * resy update scheduling mechanism and react's update execution mechanism for text input.
      *
      * todo notes：react itself, even the version of react V18+,
      * There is a problem that asynchronous updates make it impossible to input text in languages other than English.
      * eg: (xxxpromise).then(() => { setState(xxx); });
      *
      * todo：At the same time, "syncUpdate" can also be used by development partners
      * who do not like to use callbacks to get the latest data.
      * Because after it is executed, it can get the latest data through store
      * for the next step of business logic processing.
      */
    store.syncUpdate({
      inputValue: event.target.value,
    });
  }
  
  return (
    <input value={inputValue} onChange={inputChange}/>
  );
}
```

### useRocketState
```tsx
import { useRocketState } from "resy";

const initialState = {
  count: 123,
  text: "hello-rocket",
};

function App() {
  // const privateStore = useMemo(() => createStore({ count: 0, text: "QWE }, { privatization: true }), []);
  // const { count, text, setState } = useStore(privateStore);
  /**
   * The above usage is equivalent to the native useState of react in effect.
   * const [count, setCount] = useState(0);
   * const [text, setText] = useState("QWE");
   * 
   * The useRocketState hook is the implementation of the above code.
   * It can be seen that privatization is mainly for useRocketState to simplify
   * the configuration of useState.
   */
  const {
    count, text, setState,
    // syncUpdate, subscribe,
  } = useRocketState(initialState);
  
  function addClick() {
    setState({
      count: count + 1,
      text: "ASD",
    });
  }
  
  return (
    <>
      <div onClick={addClick}>{count}</div>
      <div>{text}</div>
    </>
  );
}
```

### subscribe
```tsx
import { useEffect } from "react";
import { useStore } from "resy";

function App() {
  const { count } = useStore(store);
  
  // Here is an example of a function component.
  // If it is a class component, it can be used in componentDidMount.
  useEffect(() => {
    /**
     * @description subscribe is a method to mount on each store
     *
     * @param listener: subscription monitoring callback function
     * @param stateKeys: subscription listens for changes in certain data fields of a specific store.
     * If empty, default listens for changes in any one of the data in store.
     * @return Unsubscribe: unsubscribe to the function of listening
     */
    const unsubscribe = store.subscribe((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectState：Currently changing data
       *   prevState：Data before change
       *   nextState：Data after change
       */
      console.log(effectState, prevState, nextState);
    }, ["count", "text"]);
    
    // unsubscribe();
    return () => {
      unsubscribe();
      // ... to do else anything
    };
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "control btn-b click update text state value";
  }
	
  function btnClickC() {
    store.setState({
      count: count + 1,
      text: "control btn-c click update text state value",
    });
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>btn-A</button><br/>
      <button onClick={btnClickB}>btn-B</button><br/>
      <button onClick={btnClickC}>btn-C</button>
    </>
  );
}
```

### avoid "redundant re-render"
```tsx
import { createStore, useStore } from "resy";

const store = createStore({
  count: 0,
  text: "hello",
  countAddFun: () => {
    store.count++;
  },
});

// Changes in the state of count data will not cause re-render in Text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Changes in the state of text data will not cause re-render in Count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

function App() {
  const { countAddFun, name } = useStore(store);
  /**
   * updates to each other's data between text and count will not affect the re-rendering of each other's components.
   * but after the state of their common parent component App, such as name has changed.
   * it will still force the re-rendering of the Text and Count components.
   * this kind of rendering is unnecessary. We can use "view" to avoid it.
   * continue to see the introduction to view in the next section.
   */
  return (
    <>
      <Text/>
      <Count/>
      <div>{name}</div>
      <button onClick={() => { store.name = "app"; }}>btn-name</button>
      <button onClick={countAddFun}>btn+</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        btn-
      </button>
    </>
  );
}
```

### view
```markdown
Summary: compared with resy's own feature of avoiding extra re-render,
         view is more perfect for avoiding redundant re-render.

The perfect point is:
    Components wrapped by view,
    as long as the data in the parent component is not used.
    Then even if the parent component is updated,
    the component of the view package will not re-render.
```

```tsx
import React from "react";
import { useStore, MapStateToProps, view } from "resy";

/**
 * view's support for class components requires props.
 * You can write StateToProps<StateType>
 * in the paradigm of the component's inherited component PureComponent/ComponentMap.
 * The state data mounted on props can be used through this.props.state.
 */
class ClassCom extends React.Component<MapStateToProps<StateType>> {
  render() {
    const { count, text } = this.props.state;
    return (
      <div>{count}{text}</div>
    );
  }
}

// function HookCom(props: MapStateToProps) {
//   const { count, text } = props.state;
//   return (
// 	<div>{count}{text}</div>
//   );
// }
/**
 * View supports Hook components in the same way as class components through props.
 * You can also deconstruct reading using useStore (store) directly in the Hook component.
 * The effect of the two is the same, but also more convenient.
 */
function HookCom() {
  const { count, text } = useStore(store);
  return (
    <div>{count}{text}</div>
  );
}

/**
 * view
 * @description Help components automatically handle high-level HOC of SCU and memo.
 * @param store: store generated by createStore
 * @param Comp: wrapped component
 * @param deepEqual: props、state Depth contrast
 * It will make a deep comparison between props and state and previous props and state.
 * Whether to enable it or not requires developers to measure the performance benefits they can bring.
 * Normally, it is not necessary to enable this feature.
 * Unless you encounter a very heavy component rendering that consumes a lot of performance,
 * it is enabled to reduce the burden of page update rendering through the calculation of JS.
 */
// const TestView = view(store, HookCom);
const TestView = view(store, ClassCom);

function App() {
  const { countAddFun, name } = useStore(store);
  
  return (
  	<>
      <Text/>
      <Count/>
      {/* name data update, will not cause TestView re-render */}
      <TestView/>
      <div>{name}</div>
      <button onClick={() => { store.name = "app"; }}>btn-name</button>
      <button onClick={countAddFun}>btn+</button>
      <button
        onClick={() => {
        	store.count--;
        }}
      >
        btn-
      </button>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [刘善保](https://github.com/lsbFlying)

