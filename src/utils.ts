import { REGENERATIVE_SYSTEM_KEY } from "./static";
import type { PrimitiveState, MapType, State, CreateStoreOptions } from "./model";
import { Listener, SetStateCallback } from "./model";

export const hasOwnProperty = Object.prototype.hasOwnProperty;

// storeä¼ çš„ä¸æ˜¯ç”±resyæœ¬èº«çš„createStoreåˆ›å»ºäº§ç”Ÿçš„storeçš„é”™è¯¯å¤„ç†
export const storeErrorHandle = <S extends PrimitiveState>(store: S, fnName: "useStore" | "view") => {
  if (!store[REGENERATIVE_SYSTEM_KEY as keyof S]) {
    throw new Error(
      `resy's ${
        fnName
      }(...): Expected the 'store' argument should be generated by resy's createStore(...). Instead received: ${
        store
      }.`
    );
  }
};

const toString = Object.prototype.toString;

// æ•°æ®æ›´æ–°å‚æ•°æŠ¥é”™å¤„ç†
export const stateErrorHandle = <S extends PrimitiveState>(
  stateParams: State<S>,
  fnName: "setState" | "syncUpdate" | "createStore",
) => {
  if (toString.call(stateParams) !== "[object Object]") {
    throw new Error(
      `resy's ${fnName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (
    (stateParams as Partial<S>)?.[REGENERATIVE_SYSTEM_KEY as keyof S]
  ) {
    console.error(
      `Warning: resy's ${fnName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

// createStoreçš„optionsé…ç½®é”™è¯¯å¤„ç†
export const optionsErrorHandle = (fnName: "setOptions" | "createStore", options?: CreateStoreOptions) => {
  if (options !== undefined && typeof options?.unmountRestore !== "boolean") {
    throw new Error(
      `resy's ${fnName}(...): Expected the ${
        fnName === "createStore" ? "last optional" : ""
      } 'options' argument to be a CreateStoreOptions type params. Instead received: ${options}.`
    );
  }
};

// subscribeçš„å‚æ•°é”™è¯¯å¤„ç†
export const subscribeErrorHandle = <S extends PrimitiveState>(
  listener: Listener<S>,
  stateKeys?: (keyof S)[],
) => {
  if (typeof listener !== "function") {
    throw new Error(
      `resy's subscribe(...): Expected the first optional 'listener' argument to be a function. Instead received: ${listener}.`
    );
  }
  if (stateKeys !== undefined && toString.call(stateKeys) !== "[object Array]") {
    throw new Error(
      `resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. Instead received: ${stateKeys}.`
    );
  }
};

export const setStateCallbackErrorHandle = <S extends PrimitiveState>(callback?: SetStateCallback<S>) => {
  if (callback !== undefined && typeof callback !== "function") {
    throw new Error(
      `resy's setState(...): Expected the last optional 'callback' argument to be a function. Instead received: ${callback}.`
    );
  }
};

/**
 * storeè¢«è®¾ç½®ä¸ºæŸå¯¹è±¡çš„åŸå‹çš„é”™è¯¯å¤„ç†
 * @description é˜²æ­¢æœ‰å¯¹è±¡ç»§æ‰¿äº†createStoreç”Ÿæˆçš„ä»£ç†å¯¹è±¡ï¼Œ
 * åŒæ—¶initialStateå±æ€§ä¸­åˆæœ‰ "å±æ€§æè¿°å¯¹è±¡" çš„get (getter) æˆ–è€…set (setter) å­˜å–å™¨ çš„å†™æ³•
 * ä¼šå¯¼è‡´proxyä¸­çš„receiverå¯¹è±¡æŒ‡å‘çš„thisä¸Šä¸‹æ–‡å¯¹è±¡å˜åŒ–
 * ä½¿å¾— get / set æ‰€å¾—åˆ°çš„æ•°æ®äº§ç”ŸéæœŸæœ›çš„æ•°æ®å€¼
 * setä¸ä¼šå½±å“æ•°æ®ï¼Œå› ä¸ºsetä¹‹åä¼šä»proxyçš„getèµ°ï¼Œæ‰€ä»¥åªè¦æ§åˆ¶å¥½getå³å¯ä¿è¯æ•°æ®çš„æ­£ç¡®æ€§
 * detail course:
 * ä¸ºäº†æœç»è¿™ç§å¤æ‚çš„æ˜“äº§ç”Ÿbugçš„é—®é¢˜ï¼Œæ‰€ä»¥ç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œæé†’å¼€å‘è€…ç¦æ­¢ç–‘éš¾æ‚ç—‡çš„ä»£ç å†™æ³•
 * å› ä¸ºä¸ç¦æ­¢å°±è¦æ—¢è¦è§£å†³getåˆè¦è§£å†³setï¼Œä¸¤æ–¹é¢ç»¼åˆèµ·æ¥å¾ˆéº»çƒ¦ï¼Œ
 * è€Œä¸”æœ¬èº«è¿™ç§ä¸œè¥¿å°±æ˜¯å®¹æ˜“è¯¯å¯¼äººæˆ–è€…è¯´éš¾ä»¥ç†æ¸…çš„å†™æ³•ï¼Œç¦æ­¢æ˜¯æœ€å¥½çš„è€ƒé‡
 */
export const protoPointStoreErrorHandle = (receiver: any, store: any) => {
  if (receiver !== store) {
    console.error(
      "Warning: It is not recommended that store be inherited as a prototype object," +
      " because there is no this pointing to the target object corresponding to the Reflect proxy within store!"
    );
  }
};

/**
 * @description è·Ÿè¿›çŠ¶æ€map
 * ç›¸è¾ƒäºç›´æ¥èµ‹å€¼æ–°å€¼çš„æ–¹å¼ä¹Ÿæ›´å¿«
 */
export const followUpMap = <K, V>(map: Map<K, V>) => {
  const mapTemp: Map<K, V> = new Map();
  map.forEach((value, key) => {
    mapTemp.set(key, value);
  });
  return mapTemp;
};

/**
 * mapè½¬object
 * @description è§£å†³å›è°ƒå‚æ•°å¦‚æœæ˜¯mapçš„proxyä»£ç†çš„è¯æ— æ³•åšæ‰©å±•è¿ç®—çš„é—®é¢˜
 * ä½¿ç”¨mapçš„foreachä¹Ÿå¯ä»¥ï¼Œå¹¶ä¸”åœ¨æ•°æ®é‡è¾ƒå¤§çš„æ—¶å€™æ¯”for ofæ›´å¿«ï¼Œ
 * ä½†æ˜¯è¿™é‡Œä¸€èˆ¬æ•°æ®é‡è®¤ä¸ºä¸è¿‡è¿‡å¤§è¾¾åˆ°ç™¾ä¸‡çº§åˆ«ï¼Œä¸”åœ¨å¤§æ•°æ®é‡çš„æ—¶å€™å¹¶æ²¡æœ‰æ‹‰å¼€è¶³å¤Ÿçš„å·®è·
 * æ‰€ä»¥for ofçš„æ–¹å¼ä¾æ—§æ˜¯ä¼—å¤šæ–¹å¼ä¸­æœ€ç»¼åˆé«˜æ•ˆçš„æ–¹å¼
 */
export const mapToObject = <S extends PrimitiveState>(map: MapType<S>): S => {
  const object = {} as S;
  for (const [key, value] of map) {
    object[key] = value;
  }
  return object;
};

/**
 * objectè½¬map
 * @description æ€§èƒ½ç›¸å¯¹è¾ƒé«˜çš„æµ…è½¬æ¢
 */
export const objectToMap = <S extends PrimitiveState>(object: S) => Object.keys(object)
  .reduce((prev, key) => {
    prev.set(key, object[key]);
    return prev;
  }, new Map());

/**
 * æ¸…ç©ºå¯¹è±¡
 * @description åœ¨æœªè¾¾åˆ°ç™¾ä¸‡çº§åˆ«çš„æ•°æ®é‡çš„æ—¶å€™è¯¥å®ç°æ–¹å¼ç›¸å¯¹å…·æœ‰è¾ƒå¤§ä¼˜åŠ¿
 * ä¸”åœ¨å³ä½¿æ¥è¿‘æˆ–è€…è¾¾åˆ°ç”šè‡³è¶…è¿‡ç™¾ä¸‡çº§åˆ«çš„æ•°æ®é‡çš„æƒ…å†µä¸‹è¯¥æ–¹å¼ä»ç„¶ä¸å…¶ä»–å®ç°æ–¹å¼ç›¸å·®æ€§èƒ½ä¸å¤§
 * æ‰€ä»¥ä¸‹é¢çš„å®ç°æ–¹å¼ä»ç„¶æ˜¯ç›¸å¯¹æœ€ä¼˜è§£
 *
 * ğŸŒŸæ— è®ºæ˜¯mapToObjectã€objectToMapè¿˜æ˜¯clearObjectï¼Œéƒ½æ˜¯å¯¹æ€§èƒ½å’Œå†…å­˜çš„ç»¼åˆè€ƒé‡
 * æœ¬èº«å¤–éƒ¨æ˜¯ä½¿ç”¨objectè‚¯å®šæ˜¯å¤§å¤šæ•°åœºæ™¯ï¼Œä½†æ˜¯å†…éƒ¨ä½¿ç”¨è½¬æ¢ä¸€å±‚mapã€setæ˜¯å‡ºäºmapã€setçš„æ€§èƒ½ä¼˜è¶Šæ€§è€ƒè™‘
 * ä½†æ˜¯è¿™æ ·ä¸€æ¥ä¼¼ä¹ä¸äº’ç›¸è½¬æ¢çš„æˆæœ¬ä¸­æ­¤æ¶ˆå½¼é•¿ï¼Œä½†å®é™…ä¸Šå¹¶éå¦‚æ­¤ï¼Œé¦–å…ˆå°±mapToObjectè€Œè¨€
 * çºµè§‚resyçš„æ•´ä¸ªæºç ä¸­ï¼Œå®ƒçš„ä½¿ç”¨åœºæ™¯éƒ½æ˜¯å°‘æ•°åœºæ™¯ï¼Œå³ä½¿åœ¨setStateã€syncUpdateä¸­çš„å‡½æ•°å‚æ•°çš„æ›´æ–°åœºæ™¯ä¸­ä¹Ÿæ˜¯ä¸å¸¸è§ä¸å¸¸ç”¨çš„
 * å…¶æ¬¡æ˜¯objectToMapï¼Œå®ƒçš„ä½¿ç”¨åœºæ™¯ä¸€æ˜¯createStoreä¸­çš„é™æ€åˆå§‹åŒ–æ‰§è¡Œä½¿ç”¨ï¼Œè¿™ç‚¹å¹¶éè¿è¡Œä¸­ä½¿ç”¨ï¼Œ
 * ä¸”resyè®¤ä¸ºstoreä½œä¸ºåˆ†åŒ–å¹¶éç»Ÿä¸€ç‹¬ä¸€çš„storeè€Œè¨€ä¸å­˜åœ¨å¤§æ•°æ®ç¨‹åº¦çš„å±æ€§æŒ‚è½½ï¼Œå¸¸è§„ä½¿ç”¨åŸºæœ¬ä¸ä¼šå½±å“å…¶è¿è¡Œæ€§èƒ½ï¼Œ
 * äºŒæ˜¯åœ¨viewä¸­çš„ä½¿ç”¨åœºæ™¯ï¼Œè€Œviewæœ¬èº«æ˜¯memoç»“åˆresyçš„è¿›é˜¶ï¼Œmemoæœ¬èº«æ˜¯æœ‰ç¼“å­˜ä¼˜åŒ–ï¼Œç»“åˆè¿™ç‚¹ä¹Ÿä¸ä¼šå­˜åœ¨æ€§èƒ½æ¶ˆè€—ï¼Œ
 * ä¸”viewçš„æ—¶å€™æ˜¯é’ˆå¯¹è€—æ€§èƒ½çš„ç»„ä»¶è€Œè¨€ï¼Œæ‰€ä»¥è¿™ç‚¹ç»“åˆstoreä¸ä¼šæœ‰å¤§æ•°æ®å±æ€§æŒ‚è½½çš„æƒ…å†µç»¼åˆè€Œè¨€ä¹Ÿæ˜¯ä¸ä¼šæœ‰æ€§èƒ½é—®é¢˜çš„ï¼Œ
 * æ‰€ä»¥mapToObjectã€objectToMapæ•´ä½“ç»¼åˆè€ƒé‡æ˜¯ç”±äºobjectçš„ä½¿ç”¨æƒ…å†µçš„ã€‚
 * æœ€åä¸€ç‚¹æ˜¯clearObjectï¼Œå¯ä»¥ç¡®å®šçš„æ˜¯å®ƒçš„æ‰§è¡Œæ¶ˆè€—è‚¯å®šæ˜¯æ¯”ç›´æ¥ä¸€ä¸ªç©ºå¯¹è±¡èµ‹å€¼è¦å¤šï¼Œä½†æ˜¯å‡ºäºå†…å­˜è€ƒè™‘
 * æˆ‘ä»¬è®¤ä¸ºå‡å°‘å†…å­˜å ç”¨ä¹Ÿæ˜¯ä¸€éƒ¨åˆ†ä¼˜åŒ–åœºæ™¯æœ‰å¿…è¦çš„ï¼Œå¦åˆ™å°±ä¼šæœ‰å¤§é‡çš„reduceä¸­çš„æ‹†ç¦»å¤„ç†çš„å‡½æ•°å›åˆ°createStoreçš„å†…éƒ¨å½“ä¸­
 * è¿™æ ·äº§ç”Ÿçš„å†—ä½™å†…å­˜åœ¨ä¸€ä¸ªç³»ç»Ÿä¸­å¯èƒ½å ç”¨çš„å†…å­˜æ˜¯å¾ˆå¯è§‚çš„ï¼Œä¼˜åŒ–è¿™ä¸€éƒ¨åˆ†å†…å­˜å ç”¨æ˜¯æœ‰å¿…è¦çš„ã€‚
 * æ€»è€Œè¨€ä¹‹ï¼Œæ€§èƒ½ä¸å†…å­˜å°±åƒç‰©ç†å­¦ä¸­çš„P=FVï¼Œå¯¹åº”åˆ°ç°å®ä¸–ç•Œä¸­å°±åƒåŠ›é‡ä¸é€Ÿåº¦çš„ç»“åˆï¼Œè‚Œè‚‰å¤§åŠ›é‡å¤§ä½†æ˜¯é€Ÿåº¦é™ä½ï¼Œé€Ÿåº¦å¿«ä½†æ˜¯åŠ›é‡å°±ä¼šå°
 * æˆ‘ä»¬å¯»æ±‚çš„æ˜¯ä¸€ä¸ªFVçš„æœ€å¤§æˆ–è€…æœ€ç»¼åˆå…¨é¢çš„éœ€æ±‚è€ƒè™‘ï¼Œæ‰€ä»¥ç›®å‰çš„è€ƒè™‘å³æ˜¯å¦‚æ­¤ï¼Œåç»­æœ‰æ›´ä¼˜è§£å†è¿›ä¸€æ­¥åŠ å¼º
 */
export const clearObject = <S extends PrimitiveState>(object: S) => {
  for (const key in object) {
    if (hasOwnProperty.call(object, key)) {
      delete object[key];
    }
  }
};
