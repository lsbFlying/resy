import type { PrimitiveState } from "../types";
import type { StoreOptions, StateCallback } from "./types";
import { __REGENERATIVE_SYSTEM_KEY__ } from "./static";
import { whatsType } from "../utils";
import { __DEV__ } from "../static";

// Check whether the store is generated by Resy's createStore
export const storeErrorHandle = (
  store: unknown,
  fnName: "useStore" | "connectStore",
) => {
  if (__DEV__ && !(store as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    throw new Error(
      `resy's ${
        fnName
      }(...): Expected the 'store' argument should be generated by resy's createStore(...). Instead received: ${
        whatsType(store)
      }.`
    );
  }
};

// Error processing of data update parameters type
export const stateErrorHandle = (
  stateParams: unknown,
  fnName: "setState | syncUpdate" | "createStore",
) => {
  const stateParamsType = whatsType(stateParams);
  if (__DEV__ && stateParamsType !== "Object") {
    throw new Error(
      `resy's ${fnName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (__DEV__ && (stateParams as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    console.error(
      `Warning: resy's ${fnName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

// Options configuration type error handling of createStore
export const optionsErrorHandle = (
  fnName: "setOptions" | "createStore",
  options?: unknown,
) => {
  const optionsType = whatsType(options);
  const optsExist = optionsType !== "Undefined";
  const ur = (options as StoreOptions)?.unmountRestore;
  const usm = (options as StoreOptions)?.__useConciseStateMode__;
  const urType = whatsType(ur);
  const usmType = whatsType(usm);
  if (
    __DEV__ && (optsExist && optionsType !== "Object") || (
      optsExist && (
        (urType !== "Boolean" && urType !== "Undefined")
        || (usmType !== "Boolean" && usmType !== "Undefined")
      )
    )
  ) {
    throw new Error(
      `resy's ${fnName}(...): Expected the ${
        fnName === "createStore" ? "last optional" : ""
      } 'options' argument to be a StoreOptions type params. Instead received: ${
        optionsType
      }.`
    );
  }
};

// Parameter type error handling of subscribe
export const subscribeErrorHandle = (
  listener: unknown,
  stateKeys?: unknown,
) => {
  const listenerType = whatsType(listener);
  const stateKeysType = whatsType(stateKeys);
  if (__DEV__ && listenerType !== "Function") {
    throw new Error(
      `resy's subscribe(...): Expected the first optional 'listener' argument to be a function. Instead received: ${
        listenerType
      }.`
    );
  }
  if (__DEV__ && stateKeysType !== "Undefined" && stateKeysType !== "Array") {
    throw new Error(
      `resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. Instead received: ${
        stateKeysType
      }.`
    );
  }
};

// Callback function type error handling
export const stateCallbackErrorHandle = <S extends PrimitiveState>(callback?: StateCallback<S>) => {
  const callbackType = whatsType(callback);
  if (__DEV__ && callbackType !== "Undefined" && callbackType !== "Function") {
    throw new Error(
      `resy's stateCallback(...): Expected the last optional 'callback' argument to be a function. Instead received: ${
        callbackType
      }.`
    );
  }
};

/**
 * @description Error handling when store is set as the prototype of an object
 * Since the receiver object in the proxy
 * that points to the this context object will change with the prototype,
 * such uncontrollable changes can cause incompatibility issues
 * or create discrepancies in understanding with the data returns within the store.
 * Therefore, it is not recommended to perform the uncommon
 * and discordant operation of 'setting the store as the prototype object of certain objects'.
 * ðŸŒŸ Note: The discordant issues are mainly caused by the object's property descriptors,
 * such as set and get. Specific examples will not be provided here,
 * for more details, you may refer to the explanations of the receiver in the context of a proxy.
 */
export const protoPointStoreErrorHandle = (receiver: any, store: any) => {
  if (__DEV__ && receiver !== store) {
    console.error(
      "Warning: It is not recommended that store be inherited as a prototype object," +
      " because there is no this pointing to the target object corresponding to the Reflect proxy within store!"
    );
  }
};
