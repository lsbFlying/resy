import { _RE_DEV_SY_, STORE_VIEW_MAP_KEY, USE_STORE_KEY } from "./static";
import type {
  State, Store, StoreViewMapType, StoreViewMapValue, Stores, ValueOf, MapType,
} from "./model";

/**
 * 给Comp组件的props上挂载的state属性数据做一层引用代理
 * @description 核心作用是找出SCU或者useMemo所需要的更新依赖的数据属性
 */
export function proxyStateHandler<S extends State>(
  stateMap: MapType<S>,
  innerUseStateSet: Set<keyof S>,
) {
  const store = new Proxy(stateMap, {
    get: (target: MapType<S>, key: keyof S, receiver: any) => {
      innerUseStateSet.add(key);
      /**
       * stateMap(即最新的状态数据Map-latestState)给出了resy生成的store内部数据的引用，
       * 这里始终能获取到最新数据
       * 同时兼容考虑Reflect的bug兼容写法
       */
      return receiver === store
        ? target.get(key)
        : Reflect.get(target, key, receiver);
    },
  } as ProxyHandler<MapType<S>>) as object as S;
  return store;
}

// view的多store的最新数据的处理
export function viewStoresToLatestState<S extends State>(stores: Stores<S>) {
  const latestStateTemp = {} as { [key in keyof Stores<S>]: ValueOf<S> };
  for (const storesKey in stores) {
    if (Object.prototype.hasOwnProperty.call(stores, storesKey)) {
      latestStateTemp[storesKey] = mapToObject(getLatestStateMap(stores[storesKey]));
    }
  }
  return latestStateTemp as S;
}

// view的多个store的state更新处理
export function viewStoresStateUpdateHandle<S extends State>(
  state: { [key in keyof Stores<S>]: S },
  innerUseStateSet: Set<keyof S>,
  nextState: S,
  storesKey?: keyof Stores<S>,
) {
  const stateTemp: { [key in keyof Stores<S>]: S } = Object.assign({}, state);
  Object.keys(state).forEach(storesKeyItem => {
    if (storesKey === storesKeyItem) {
      stateTemp[storesKey] = proxyStateHandler(new Map(Object.entries(nextState)), innerUseStateSet)
    }
  });
  return stateTemp;
}

/**
 * map转object
 * @description 解决回调参数如果是map的proxy代理的话无法做扩展运算的问题
 */
export function mapToObject<S extends State>(map: MapType<S>): S {
  return [...map.entries()].reduce((obj, [key, value]) => ((obj as S)[key] = value, obj), {}) as S;
}

/**
 * object转map
 * @description 相较于简洁的object.entries方式效率更高
 */
export function objectToMap<S extends State>(obj: S) {
  const map: MapType<S> = new Map();
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      map.set(key, obj[key]);
    }
  }
  return map;
}

// 获取最新数据Map对象
export function getLatestStateMap<S extends State = {}>(store?: Store<S>) {
  if (!store) return new Map() as MapType<S>;
  return (
    (
      store[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
    ).get("getStateMap") as StoreViewMapValue<S>["getStateMap"]
  )();
}

// store传的不是由resy本身的createStore创建产生的store的错误处理
export function storeErrorHandle<S extends State>(store: S) {
  if (_RE_DEV_SY_ && !store[USE_STORE_KEY as keyof S]) {
    throw new Error("The store parameter is not created by resty's createStore！");
  }
}

// 数据更新参数报错处理
export function updateDataErrorHandle<S extends State>(
  stateParams: Partial<S>,
  fnName: "setState" | "syncUpdate",
) {
  if (
    _RE_DEV_SY_ && (
      (
        Object.prototype.toString.call(stateParams) !== "[object Object]"
        && Object.prototype.toString.call(stateParams) !== "[object Function]"
      )
    )
  ) {
    throw new Error(`The state parameter of ${fnName} is either an object or a function that returns an object!`);
  }
  if (
    _RE_DEV_SY_
    && Object.prototype.toString.call(stateParams) === "[object Object]"
    && (stateParams as Partial<S>)[USE_STORE_KEY as keyof S]
  ) {
    throw new Error(`The state parameter of ${fnName} is the store generated by createStore and has no update significance!`);
  }
}

/**
 * @description 很难想象什么样的复杂的逻辑需要处理函数属性的更新，
 * 更何况本身resy还要处理函数属性的this问题，
 * 所以这里就禁用函数属性的更新，并以报错处理提示开发人员
 */
export function fnPropUpdateErrorHandle<S extends State>(key: keyof S, val: ValueOf<S>) {
  if (_RE_DEV_SY_ && typeof val === "function") {
    throw new Error(`"${key as string}" is a function, can not update!`);
  }
}
