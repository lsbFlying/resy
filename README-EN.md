<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Native„ÄÅSSR„ÄÅMini WeChat Apps (with platform compatible processing, such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=red&style=flat-square)](https://github.com/lsbFlying/resy/actions?query=workflow%3ATest)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/resy?color=brightgreen&style=flat-square)](https://bundlephobia.com/result?p=resy)

[ÁÆÄ‰Ωì‰∏≠Êñá](./README.md) ¬∑ English
</div>

---

### Features
- Support hook components and class components üòé
- Fine grained update, better avoid re-render üòé
- Easy to use, and the learning cost is almost zero üòé

### Install
```sh
npm i resy

# yarn add resy
```

### Overview
resy requires react version V >= 16.8; resy has five APIs, which are:
- resyÔºöStorage container for generating a global status data
- useResyÔºöHook that drives component updates
- resyUpdateÔºöupdate or batch update status data
- resyListenerÔºösubscribe and listen for changes in store data generated by resy
- resyViewÔºöHelp components have the ability to "better avoid re-render"

### resy„ÄÅuseResy
```tsx
import { resy, useResy } from "resy";

// Data paradigm type interface
type ResyStore = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};
// The generated store can be shared globally and can be imported directly
const store = resy<ResyStore>(
  {
    count: 0,
    text: "123qwe",
    testObj: { name: "Paul" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  /**
   * The default is true
   * True: the initialization data state is automatically restored when the default component is uninstalled
   * False: the initialization data is not recovered when the component is uninstalled, and the data state is maintained
   * General usage scenarios can be set to true
   * Special use scenarios, such as login information data
   * Alternatively, the theme data belongs to the global status data and can be set to false
   */
  // false,
);

function App() {
  /**
   * useresy is used for driver update of components, If you use store directly without useresy,
   * Only the pure data can be obtained, and component update and re rendering cannot be driven.
   */
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useResy(store);

  // Or: const snapshot = useResy(store);
  // snapshot.count; ...etc
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}
    </>
  );
}
```

### Direct update
```tsx
import { useResy } from "resy";

function App() {
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useResy(store);
  
  function btn2() {
    /**
     * It should be noted that resy has automatic batch update
     * In addition, the batch update of resy can make up for the version below react v18.
     * In places where react cannot manage, such as promise or setTimeout, batch update also has the effect
     */
    // It can be updated by direct assignment (the simplest update method)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chain update is not allowed, Because resy proxy only maps the data attributes of the first layer
     * For performance reasons, deep recursive proxy is not currently available, The following update methods are invalid
     */
    // store.testObj.name = "Jack";
    // New value assignment required (valid update)
    store.testObj = {
      name: "Jack",
    };
    /**
     * Similarly, arrays are not allowed to update data by directly changing the index value
     * In this way, the security update is used.
     */
    // store.testArr[0] = { age: 7 };
    // Also need new value assignment required (valid update)
    store.testArr = [{ age: 7 }];
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}<br/>
      <button onClick={btn2}>Button2</button>
    </>
  );
}
```

### resyUpdate ‚Äî update
```tsx
function App() {
  function btnClick() {
    /**
     * 1„ÄÅThe main reason why resy needs resyupdate is that it needs the callback function of resyupdate
     * The parameters of its callback function are the latest data, or the latest data can be obtained through store. In the callback function
     * Because the update of resy is asynchronous, the callback of resyupdate is required when the data needs to be obtained synchronously
     * It is equivalent to the callback of setstate
     * Second, resyupdate's own use mode has good reading and writing ability during coding,
     * the convenience of updating object data and the ability to directly write
     * and cycle updates all make resyupdate have stronger vitality.
     * 
     * 2„ÄÅresyupdate is a method of attaching to each store data generated by resy
     */
    // @example A
    store.resyUpdate({
      count: count++,
      text: "456asd",
    }, (state) => {
      // stateÔºöLatest data value
      // It can be understood that state is this in the callback function of "this.setstate" state
      // At the same time, this also makes up for:
      // In the hook component, the latest data can only be obtained through useeffect after setstate
      console.log(state);
    });
    // B way can directly write circular updates in the callback function,
    // which is more convenient for the update of some complex business logic
    // @example B
    // store.resyUpdate(() => {
    //   store.count++;
    //   store.text = "456asd";
    // }, (state) => {
    //   console.log(state);
    // });
  }
  
  return (
    <button onClick={btnClick}>Button</button>
  );
}
```

### resyListener ‚Äî Subscription listening
```tsx
import { useEffect } from "react";
import { resyListener, useResy } from "resy";

function App() {
  const { count } = useResy(store);
  
  /**
   * Here is an example of a function component
   * If it is a class component, you can use resylistener in componentDidMount
   */
  useEffect(() => {
    /**
     * @param listener: Callback function of subscription listening
     * @param store: Subscribe to monitor the data status changes of a specific store container
     * @param listenerKey: Subscribe to the change of some data field of a specific store container monitored
     * If it is empty, it will listen to the changes of any data in the store by default.
     * @return Callback: Return the function of unsubscribing
     */
    const cancelListener = resyListener((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectStateÔºöCurrent changing data
       *   prevStateÔºöData before change
       *   nextStateÔºöData after change
       */
      console.log(effectState, prevState, nextState);
    }, store, ["count", "text"]);
  
    // Unsubscribe
    // cancelListener();
    return cancelListener;
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "qweiop123";
  }
	
  function btnClickC() {
    store.count++;
    store.text = "098123kjhkhdfs";
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>ButtonA</button><br/>
      <button onClick={btnClickB}>ButtonB</button><br/>
      <button onClick={btnClickC}>ButtonC</button>
    </>
  );
}
```

### Avoidance re-render of resy its own characteristics
```tsx
import { resy, useResy } from "resy";

const store = resy({
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

// The change of count data state will not cause the re render of text
function Text() {
  const { text } = useResy(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re render of count
function Count() {
  const { count } = useResy(store);
  return <p>{count}</p>;
}

/**
 * No extra rendering to avoid re render does not mean - "the parent component renders the child component and still does not render".
 * Re render refers to:
 * If a and B are at the same level, the data of components at the same level a or sub level a is rendered,
 * it will not lead to the rendering of B components.
 * If the parent component renders the child component, it must render without SCU or useMemo. After all
 */
function App() {
  const { countAddFun } = useResy(store);
  return (
    <>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
    </>
  );
}
```

### resyView ‚Äî Better avoid re render
```tsx
// store single file
import { resy } from "resy";

export type StoreType = {
  appTestState: string;
  classComTestState: string;
  hookComTestState: string;
  count: number;
  text: string;
  countAddFun: () => void,
};

const store = resy({
  appTestState: "appTestState",
  classComTestState: "classComTestState",
  hookComTestState: "classComTestState",
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

export default store;
```

```tsx
// resyView support for class components
import React from "react";
import { resyView, ResyStateToProps } from "resy";
import store, { StoreType } from "store";

class ClassCom extends React.PureComponent<ResyStateToProps<StoreType>> {
  /**
   * First of all, count and text, hookcomteststate data attributes in the store
   * Cannot affect the re-render of classcom
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of classcom
   * Only the classcomteststate data referenced by classcom itself will affect its rendering
   *
   * That is to say, resyView has the effect of avoiding re render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  render() {
    // resyView will mount the store data to the new state attribute on props
    const { classComTestState } = this.props.state;
    console.log(classComTestState);
    return (
      <div>{classComTestState}</div>
    );
  }
}

export default resyView(store, ClassCom);
```

```tsx
// resyView support for hook components
import React from "react";
import { resyView, ResyStateToProps } from "resy";
import store, { StoreType } from "store";

const HookCom = (props: ResyStateToProps<StoreType>) => {
  // resyView will mount the store data to the new state attribute on props
  const { hookComTestState } = props.state;
  /**
   * First of all, count and text, classcomteststate data attributes in the store
   * Cannot affect hookcom's render
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of hookcom
   * Only the hookcomteststate data referenced by hookcom itself will affect its rendering
   *
   * That is to say, resyView has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  console.log(hookComTestState);
  return (
    <div>{hookComTestState}</div>
  );
}

export default resyView(store, HookCom);
```

```tsx
import React from "react";
import { useResy } from "resy";

// The change of count data state will not cause the re render of text
function Text() {
  const { text } = useResy(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re render of count
function Count() {
  const { count } = useResy(store);
  return <p>{count}</p>;
}

function App() {
  const {
    appTestState, classComTestState, hookComTestState, countAddFun,
  } = useResy(store);
  
  function appTestClick() {
    store.appTestState = `${Math.random()}~appTestState~`;
  }
  
  function classComTestStateClick() {
    store.classComTestState = `*${Math.random()}classComTestState*`;
  }
  
  function hookComTestStateClick() {
    store.classComTestState = `!${Math.random()}hookComTestState!`;
  }
  
  /**
   * Summary: compared with resy's own characteristics, re render
   * resyView handles circumvented re-render more perfectly
   *
   * The perfection lies in:
   * that is even if the parent component is updated
   * As long as resyView wraps the component itself
   * The attribute data of the update reason is not used in the parent component
   * Then the components wrapped by resyView will not be re-render
   */
  return (
    <>
      <div onClick={appTestClick}>{appTestState}</div>
      <div onClick={classComTestStateClick}>{classComTestState}</div>
      <div onClick={hookComTestStateClick}>{hookComTestState}</div>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
      <br/>
      <ClassCom/>
      <HookCom/>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [ÂàòÂñÑ‰øù](https://github.com/lsbFlying)

