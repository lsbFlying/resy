<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Native„ÄÅSSR„ÄÅMini WeChat Apps (with platform compatible processing, such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=blue&style=flat-square)](https://github.com/lsbFlying/resy/actions/workflows/test.yml)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/resy?color=brightgreen&style=flat-square)](https://bundlephobia.com/result?p=resy)

[ÁÆÄ‰Ωì‰∏≠Êñá](./README.md) ¬∑ English
</div>

---

### Features
- Support hook components and class components üòé
- Fine grained update, Better avoid redundant re-render üòé
- Easy to use, and the learning cost is almost zero üòé

### Install
```sh
npm i resy

# yarn add resy
```

### Overview
resy requires react version V >= 16.8; resy has five APIs, which are:
- createStoreÔºöCreate a storage container for global status data
- useStateÔºöUse state data in the state storage container generated from createstore
- setStateÔºöUpdate data
- subscribeÔºösubscribe and listen for changes in store data generated by createStore
- pureViewÔºöHelp components have the ability to "better avoid re-render"

### createStore„ÄÅuseState
```tsx
import { createStore, useState } from "resy";

// Data paradigm type interface
type Store = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};
// The generated store can be shared globally and can be imported directly
const store = createStore<Store>(
  {
    count: 0,
    text: "123qwe",
    testObj: { name: "Paul" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  /**
   * The default is true
   * True: the initialization data state is automatically restored when the default module is uninstalled
   * False: the initialization data is not recovered when the module is uninstalled, and the data state is maintained
   * General usage scenarios can be set to true
   * Special use scenarios, such as login information data
   * or the theme data belongs to the global status data and can be set to false
   */
  // false,
);

function App() {
  /**
   * useState is used for driver update of components, If you use store directly without useState,
   * Only the pure data can be obtained, and component update and re-rendering cannot be driven.
   * resy's useState effect is equivalent to react's native useState
   */
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useState(store);

  // Or: const state = useState(store);
  // state.count; ...etc
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}
    </>
  );
}
```

### Direct update
```tsx
import { useState } from "resy";

function App() {
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useState(store);
  
  function btn2() {
    /**
     * It should be noted that resy has automatic batch update
     * In addition, the batch update of resy can make up for the version below react v18.
     * In places where react cannot manage, such as promise or setTimeout, batch update also has the effect
     */
    // It can be updated by direct assignment (the simplest update way)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chain update is not allowed, Because resy proxy only maps the data attributes of the first layer
     * For performance reasons, deep recursive proxy is not currently available, The following update methods are invalid
     */
    // store.testObj.name = "Jack";
    // New value assignment required (valid update)
    store.testObj = {
      name: "Jack",
    };
    /**
     * Similarly, arrays are not allowed to update data by directly changing the index value,
     * and the following update way is not valid
     */
    // store.testArr[0] = { age: 7 };
    // Also need new value assignment required (valid update)
    store.testArr = [{ age: 7 }];
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}<br/>
      <button onClick={btn2}>Button2</button>
    </>
  );
}
```

### setState ‚Äî update state
```tsx
function App() {
  function btnClick() {
    /**
     * 1„ÄÅ The main reason why resy needs setState is that it needs the callback function of setState
     * The parameters of its callback function are the latest data, or the latest data can be obtained through store. In the callback function
     * Because the update of resy is asynchronous, the callback of setState is required when the data needs to be obtained synchronously
     * It is equivalent to the callback of this.setState in the class component
     * Second, the use of setState itself has good reading and writing ability during coding
     * The convenience of updating object data and the ability to directly write cyclic updates make setState have stronger vitality
     * At the same time, it also makes up for the defect that the latest data cannot be obtained immediately after the hook data status is asynchronously updated
     *
     * 2„ÄÅsetState is a method of attaching to each store container generated by resy
     */
    // @example A
    store.setState({
      count: count++,
      text: "456asd",
    }, (state) => {
      // stateÔºöLatest data value
      // It can be understood that state is this in the callback function of "this.setState" state
      // At the same time, this also makes up for:
      // In the hook component, the latest data can only be obtained through useeffect after setState
      console.log(state.count, state.text);
      // Or use store. To get the latest data value
      // console.log(store.count, store.text);
    });
    // B way can directly write circular updates in the callback function,
    // which is more convenient for the update of some complex business logic
    // @example B
    // store.setState(() => {
    //   store.count++;
    //   store.text = "456asd";
    // }, (state) => {
    //   console.log(state.count, state.text);
    // });
  }
  
  return (
    <button onClick={btnClick}>Button</button>
  );
}
```

### subscribe ‚Äî Subscription listening
```tsx
import { useEffect } from "react";
import { useState } from "resy";

function App() {
  const { count } = useState(store);
  
  /**
   * Here is an example of a function component
   * If it is a class component, you can use subscribe in componentDidMount
   */
  useEffect(() => {
    /**
     * @description subscribe is also a method of attaching to each store container generated by resy
     *
     * @param listener: Callback function of subscription listening
     * @param stateKey: Subscribe to the change of some data field of a specific store container monitored
     * If it is empty, it will listen to the changes of any data in the store by default.
     * @return Unsubscribe: Return the function of unsubscribing
     */
    const unsubscribe = store.subscribe((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectStateÔºöCurrent changing data
       *   prevStateÔºöData before change
       *   nextStateÔºöData after change
       */
      console.log(effectState, prevState, nextState);
    }, ["count", "text"]);
    
    // unsubscribe();
    return unsubscribe;
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "qweiop123";
  }
	
  function btnClickC() {
    store.count++;
    store.text = "098123kjhkhdfs";
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>ButtonA</button><br/>
      <button onClick={btnClickB}>ButtonB</button><br/>
      <button onClick={btnClickC}>ButtonC</button>
    </>
  );
}
```

### Avoidance re-render of resy its own characteristics
```tsx
import { createStore, useState } from "resy";

const store = createStore({
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useState(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useState(store);
  return <p>{count}</p>;
}

/**
 * No extra rendering to avoid re-render does not mean - "the parent component renders the child component and still does not render".
 * Re-render refers to:
 * If a and B are at the same level, the data of components at the same level a or sub level a is rendered,
 * it will not lead to the rendering of B components.
 * If the parent component renders the child component, it must render without SCU or useMemo. After all
 */
function App() {
  const { countAddFun } = useState(store);
  return (
    <>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
    </>
  );
}
```

### pureView ‚Äî Better avoid re-render
```tsx
import { createStore } from "resy";

export type Store = {
  appTestState: string;
  classComTestState: string;
  hookComTestState: string;
  count: number;
  text: string;
  countAddFun: () => void,
};

const store = createStore({
  appTestState: "appTestState",
  classComTestState: "classComTestState",
  hookComTestState: "hookComTestState",
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

export default store;
```

```tsx
// pureView support for class components
import React from "react";
import { pureView, ResyStateToProps } from "resy";
import store, { Store } from "store";

class ClassCom extends React.PureComponent<ResyStateToProps<Store>> {
  /**
   * First of all, count and text, hookcomteststate data attributes in the store
   * Cannot affect the re-render of classcom
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of classcom
   * Only the classcomteststate data referenced by classcom itself will affect its rendering
   *
   * That is to say, pureView has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  render() {
    // pureView will mount the store data to the new state attribute on props
    const { classComTestState } = this.props.state;
    console.log(classComTestState);
    return (
      <div>{classComTestState}</div>
    );
  }
}

export default pureView(store, ClassCom);
```

```tsx
// pureView support for hook components
import React from "react";
import { pureView, ResyStateToProps } from "resy";
import store, { Store } from "store";

const HookCom = (props: ResyStateToProps<Store>) => {
  // pureView will mount the store data to the new state attribute on props
  const { hookComTestState } = props.state;
  /**
   * First of all, count and text, classcomteststate data attributes in the store
   * Cannot affect hookcom's render
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of hookcom
   * Only the hookcomteststate data referenced by hookcom itself will affect its rendering
   *
   * That is to say, pureView has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  console.log(hookComTestState);
  return (
    <div>{hookComTestState}</div>
  );
}

export default pureView(store, HookCom);
```

```tsx
import React from "react";
import { useState } from "resy";

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useState(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useState(store);
  return <p>{count}</p>;
}

function App() {
  const {
    appTestState, classComTestState, hookComTestState, countAddFun,
  } = useState(store);
  
  function appTestClick() {
    store.appTestState = `${Math.random()}~appTestState~`;
  }
  
  function classComTestStateClick() {
    store.classComTestState = `*${Math.random()}classComTestState*`;
  }
  
  function hookComTestStateClick() {
    store.hookComTestState = `!${Math.random()}hookComTestState!`;
  }
  
  /**
   * Summary: compared with resy's own characteristics, re-render
   * pureView handles circumvented re-render more perfectly
   *
   * The perfection lies in:
   * that is even if the parent component is updated
   * As long as pureView wraps the component itself
   * The attribute data of the update reason is not used in the parent component
   * Then the components wrapped by pureView will not be re-render
   */
  return (
    <>
      <div onClick={appTestClick}>{appTestState}</div>
      <div onClick={classComTestStateClick}>{classComTestState}</div>
      <div onClick={hookComTestStateClick}>{hookComTestState}</div>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
      <br/>
      <ClassCom/>
      <HookCom/>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [ÂàòÂñÑ‰øù](https://github.com/lsbFlying)

