<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Nativeã€SSRã€Mini WeChat Apps (such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=blue&style=flat-square)](https://github.com/lsbFlying/resy/actions/workflows/test.yml)
[![Codecov](https://img.shields.io/codecov/c/github/lsbFlying/resy?style=flat-square)](https://codecov.io/gh/lsbFlying/resy)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)
</div>

---

##### releases what's Changed
<details>
<summary>changed logs</summary>

ğŸŒŸ`v5.0.0`ï¼š<br/>
1ã€ä¼˜åŒ–äº†ä»£ç ï¼Œä¿®å¤äº†setStateçš„æ··ç”¨åœºæ™¯çš„æ‰¹é‡è§¦å‘çš„è®¢é˜…å˜åŒ–çš„æ•°æ®ä¸å®Œå¤‡çš„bugï¼›<br/>
2ã€ä¿®å¤äº†createStoreä½œä¸ºç§æœ‰åŒ–æ•°æ®çŠ¶æ€ä½¿ç”¨çš„çš„æ–¹å¼çš„bugï¼›<br/>
3ã€æ–°å¢äº† "useRocketState" é’©å­ç®€åŒ–äº†çŠ¶æ€æ•°æ®ç§æœ‰åŒ–çš„ä½¿ç”¨æ–¹å¼ï¼›<br/>
4ã€æ–°å¢äº† "syncUpdate" åŒæ­¥æ›´æ–°apiï¼›

ğŸŒŸ`v4.0.5`ï¼š<br/>
å®Œå–„äº†setStateä¸ç›´æ¥æ›´æ–°çš„æ‰€æœ‰æ··ç”¨åœºæ™¯çš„åˆå¹¶æ›´æ–°

ğŸŒŸ`v4.0.4`ï¼š<br/>
1ã€ä¿®å¤äº†ç›´æ¥æ›´æ–°åœ¨useEffectä¸­ç›¸è¿‘çš„ä¸‹ä¸€è½®çš„æ›´æ–°æ‰¹æ¬¡ä¸­æ— æ³•å¾—åˆ°æ›´æ–°çš„bug<br/>
2ã€ä¼˜åŒ–ç›´æ¥æ›´æ–°æ–¹å¼çš„addå‡½æ•°çš„æ‰§è¡Œ<br/>
3ã€ä¼˜åŒ–äº†ç›´æ¥æ›´æ–°ä¸setStateæ‰¹é‡æ›´æ–°æ··ç”¨çš„åœºæ™¯ä¸­çš„åˆå¹¶æ›´æ–°

ğŸŒŸ`v4.0.3`ï¼š<br/>
1ã€ä¿®å¤äº†viewçš„deepEqualçš„å¯¹æ¯”propsçš„é€»è¾‘ï¼Œé¿å…äº†ç»„ä»¶å› ä¸ºpropsçš„å¼•ç”¨åœ°å€çš„ä¸åŒäº§ç”Ÿé¢å¤–æ›´æ–°æ¸²æŸ“çš„é—®é¢˜ï¼›<br/>
2ã€å®Œå–„ä¼˜åŒ–äº†æ•°æ®è®¢é˜…ç›‘å¬"subscribe"ä»£ç çš„æ‰§è¡Œæ€§èƒ½ã€‚

ğŸŒŸ`v4.0.2`ï¼š<br/>
1ã€ä¿®å¤äº†viewçš„getDerivedStateFromPropsçš„é€»è¾‘æ•°æ®ä¸ºç©ºçš„å¤„ç†bugï¼›<br/>
2ã€ä¿®å¤äº†viewåŒ…è£¹çš„ç»„ä»¶å†…éƒ¨å¯èƒ½çš„å¤æ‚å¼•ç”¨é€»è¾‘å¯¼è‡´çš„æ•°æ®å¼•ç”¨å­—æ®µçš„è·å–ç¼ºå¤±ï¼Œè¿›è€Œå¯¼è‡´çš„æ›´æ–°å¤±æ•ˆçš„bugï¼›

ğŸŒŸ`v4.0.1`ï¼šä¿®å¤äº†useStoreçš„hookInitialStateåˆå§‹åŒ–hookå‚æ•°çš„ä½¿ç”¨æ—¶ï¼Œ
å¯èƒ½å­˜åœ¨çš„å¤šæ¬¡è®¾ç½®å¯¹åº”çš„keyå€¼é—®é¢˜

ğŸŒŸ`v4.0.0`ï¼šresyè‡ªv4.0.0ç‰ˆæœ¬å¼€å§‹ï¼Œæ­£å¼è¿›å…¥ç¨³å®šå‘å±•çš„å¼€å§‹ï¼Œapiå·²å®Œæˆå‘½åä¸ä¼šè½»æ˜“å˜æ›´ï¼Œ
åŒæ—¶ä»£ç ä¹Ÿè¶‹äºç¨³å®šä¸å¼ºåŒ–ï¼Œæ¬¢è¿å¤§å®¶ä½¿ç”¨ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ

</details>

### Features
- ğŸ˜ Create simple
- ğŸ˜ Sharing freedom
- ğŸ˜ Easy to use
- ğŸ˜ Can be global or local
- ğŸ˜ Fine-grained update
- ğŸ˜ Automate SCU and memo processing

### Install
```sh
npm i resy

# yarn add resy
```

### overview
resy requires the version of react v >= 16.8, resy has seven API, which are:
- createStoreï¼šCreate a store container for global state
- useStoreï¼šUse state from the store container generated by createStore
- setStateï¼šUpdate data
- syncUpdateï¼šSynchronously update data
- useRocketStateï¼šSimplified version of useState
- subscribeï¼šSubscribe for changes in store data generated by createStore
- viewï¼šHelp components to automatically process SCU and memo

### createStore
```tsx
import { createStore, useStore } from "resy";

type StateType = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};

// The generated store can be shared globally
const store = createStore<StateType>(
  {
    count: 0,
    text: "hello",
    testObj: { name: "Jack" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  // Generally, the options configuration item does not need to be configured
  {
    /**
     * @default true
     * @description
     * if value is true, reset state to initialState after components unmounted
     * or false not reset state to initialState.
     * Unless you refresh the browser or device intentionally,
     * otherwise it will keep the data status.
     *
     * So, if situation for example login or theme,
     * we can set unmountReset is false.
     */
    unmountReset: true,
    /**
     * @description It is generally unnecessary to set it,
     * It is a configuration item used internally in the code,
     * and will be introduced in detail in combination with "useRocketState"
     */
    privatization: false,
  },
);
```

### useStore
```tsx
function App() {
  /**
   * @description You can think of it as useState, but not exactly.
   * It is used to drive component updates re-render.
   * 
   * If you directly deconstruct the store for example: 
   * const { count } = store;
   * Only simple data will be obtained, which has no update effect
   */
  const {
    count, text, testObj: { name }, testArr, testFun, inputValue,
  } = useStore(store);
  
  // Or: const state = useStore(store);
  // state.count; ...eg
  
  function btn2() {
    // Updates can be assigned directly (simple update method)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chained updates are not allowed,
     * because resy only maps the data attributes of the first layer
     * Currently, there is no in-depth recursive agent for performance reasons.
     * The following update method is invalid
     */
    // store.testObj.name = "Jack";
    store.testObj = { name: "Jack" }; // Effective update
    // Similarly, arrays are not allowed to update data by directly changing the index value,
    // and the following update method is invalid
    // store.testArr[0] = { age: 7 };
    store.testArr = [{age: 7}]; // Effective update
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>btn1</button>
      <br/>
      {testArr.map(item => `Ageï¼š${item}`)}<br/>
      <button onClick={btn2}>btn2</button>
    </>
  );
}
```

### useStore â€”â€”â€”â€” with hooks value
```tsx
import { createStore, useStore } from "resy";
import { Form } from "antd";
import { FormInstance } from "antd/es/form";

const store = createStore<{
  form?: FormInstance<{ sortNumber: number }>;
}>();

function App() {
  /**
   * If some data is generated by some hooks
   * At this point, you need to use the second parameter of useStore: hookInitialState
   *
   * If you code with typescript, the type or interface of data needs to be non-essential when defined.
   * eg: { form?: FormInstance<{ sortNumber: number }>; }
   */
  const { form } = useStore(
    store,
    {
      form: Form.useForm<{ sortNumber: number }>()[0],
    },
  );
  
  function addClick() {
    form?.setFieldsValue({
      sortNumber: 9999,
    });
  }
  
  return (
    <Form form={form} components={false}>
      <Form.Item name="sortNumber">
        <InputNumber/>
      </Form.Item>
      <br/>
      <button onClick={addClick}>btn</button>
    </Form>
  );
}
```

### setState
```tsx
function App() {
  const { count, text } = useStore(store);
  
  function btnClick() {
    /**
     * A: setState and a single direct update are asynchronous,
     * the callback function of setState can obtain the latest data.
     * setState uses objects as the data update method to have more robust coding capabilities.
     * The update method of function input parameters makes setState more robust.
     *
     * B: Resy has the effect of automatic batch updating.
     * It can make up for the effect of batch updating of versions below react v18
     * for promises or setTimeout that cannot be managed by react
     *
     * C: In most cases, setState and a single direct update are asynchronous,
     * but in some extreme cases, a batch of updates in the middle will become synchronous.
     * This is to ensure the smoothness and coordination of updates.
     */
    // @example A
    store.setState({
      count: count + 1,
      text: "BNM",
    }, (nextState) => {
      // nextStateï¼šThe latest data
      console.log(nextState.count, nextState.text);
      // Or at this time, you can read store to get the latest data.
      // console.log(store.count, store.text);
    });
    // The B way can write circular updates in the callback function
    // to facilitate the handling of some more complex business logic.
    // @example B
    // store.setState(() => {
    //   store.count++;
    //   store.text = "B-Way-setState-with-function";
    // }, (nextState) => {
    //   console.log(nextState.count, nextState.text);
    // });
  }
  
  return (
    <>
      <div>{count}</div>
      <div>{text}</div>
      <button onClick={btnClick}>btn</button>
    </>
  );
}
```

### syncUpdate
```tsx
function App() {
  const { inputValue } = useStore(store);
  
  function inputChange(event: React.ChangeEvent<HTMLInputElement>) {
    /**
      * todoï¼šThe update of this controlled input/textarea needs to be updated synchronously,
      * otherwise, due to asynchronous updates such as "store.setState" or "store[key] = newValue",
      * it will cause input/textarea unable to input characters in languages other than English.
      * todoï¼š"syncUpdate" is a helpless solution to the conflict between
      * resy update scheduling mechanism and react's update execution mechanism for text input.
      *
      * todo notesï¼šreact itself, even the version of react V18+,
      * There is a problem that asynchronous updates make it impossible to input text in languages other than English.
      * eg: (xxxpromise).then(() => { setState(xxx); });
      *
      * todoï¼šAt the same time, "syncUpdate" can also be used by development partners
      * who do not like to use callbacks to get the latest data.
      * Because after it is executed, it can get the latest data through store
      * for the next step of business logic processing.
      */
    store.syncUpdate({
      inputValue: event.target.value,
    });
  }
  
  return (
    <input value={inputValue} onChange={inputChange}/>
  );
}
```

### useRocketState
```tsx
import { useRocketState } from "resy";

const initialState = {
  count: 123,
  text: "hello-rocket",
};

function App() {
  // const privateStore = useMemo(() => createStore({ count: 0, text: "QWE }, { privatization: true }), []);
  // const { count, text, setState } = useStore(privateStore);
  /**
   * The above usage is equivalent to the native useState of react in effect.
   * const [count, setCount] = useState(0);
   * const [text, setText] = useState("QWE");
   * 
   * The useRocketState hook is the implementation of the above code.
   * It can be seen that privatization is mainly for useRocketState to simplify
   * the configuration of useState.
   */
  const {
    count, text, setState,
    // syncUpdate, subscribe,
  } = useRocketState(initialState);
  
  function addClick() {
    setState({
      count: count + 1,
      text: "ASD",
    });
  }
  
  return (
    <>
      <div onClick={addClick}>{count}</div>
      <div>{text}</div>
    </>
  );
}
```

### subscribe
```tsx
import { useEffect } from "react";
import { useStore } from "resy";

function App() {
  const { count } = useStore(store);
  
  // Here is an example of a function component.
  // If it is a class component, it can be used in componentDidMount.
  useEffect(() => {
    /**
     * @description subscribe is a method to mount on each store
     *
     * @param listener: subscription monitoring callback function
     * @param stateKeys: subscription listens for changes in certain data fields of a specific store.
     * If empty, default listens for changes in any one of the data in store.
     * @return Unsubscribe: unsubscribe to the function of listening
     */
    const unsubscribe = store.subscribe((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectStateï¼šCurrently changing data
       *   prevStateï¼šData before change
       *   nextStateï¼šData after change
       */
      console.log(effectState, prevState, nextState);
    }, ["count", "text"]);
    
    // unsubscribe();
    return () => {
      unsubscribe();
      // ... to do else anything
    };
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "control btn-b click update text state value";
  }
	
  function btnClickC() {
    store.setState({
      count: count + 1,
      text: "control btn-c click update text state value",
    });
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>btn-A</button><br/>
      <button onClick={btnClickB}>btn-B</button><br/>
      <button onClick={btnClickC}>btn-C</button>
    </>
  );
}
```

### avoid "redundant re-render"
```tsx
import { createStore, useStore } from "resy";

const store = createStore({
  count: 0,
  text: "hello",
  countAddFun: () => {
    store.count++;
  },
});

// Changes in the state of count data will not cause re-render in Text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Changes in the state of text data will not cause re-render in Count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

function App() {
  const { countAddFun, name } = useStore(store);
  /**
   * updates to each other's data between text and count will not affect the re-rendering of each other's components.
   * but after the state of their common parent component App, such as name has changed.
   * it will still force the re-rendering of the Text and Count components.
   * this kind of rendering is unnecessary. We can use "view" to avoid it.
   * continue to see the introduction to view in the next section.
   */
  return (
    <>
      <Text/>
      <Count/>
      <div>{name}</div>
      <button onClick={() => { store.name = "app"; }}>btn-name</button>
      <button onClick={countAddFun}>btn+</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        btn-
      </button>
    </>
  );
}
```

### view
```markdown
Summary: compared with resy's own feature of avoiding extra re-render,
         view is more perfect for avoiding redundant re-render.

The perfect point is:
    Components wrapped by view,
    as long as the data in the parent component is not used.
    Then even if the parent component is updated,
    the component of the view package will not re-render.
```

```tsx
import React from "react";
import { useStore, MapStateToProps, view } from "resy";

/**
 * view's support for class components requires props.
 * You can write StateToProps<StateType>
 * in the paradigm of the component's inherited component PureComponent/ComponentMap.
 * The state data mounted on props can be used through this.props.state.
 */
class ClassCom extends React.Component<MapStateToProps<StateType>> {
  render() {
    const { count, text } = this.props.state;
    return (
      <div>{count}{text}</div>
    );
  }
}

// function HookCom(props: MapStateToProps) {
//   const { count, text } = props.state;
//   return (
// 	<div>{count}{text}</div>
//   );
// }
/**
 * View supports Hook components in the same way as class components through props.
 * You can also deconstruct reading using useStore (store) directly in the Hook component.
 * The effect of the two is the same, but also more convenient.
 */
function HookCom() {
  const { count, text } = useStore(store);
  return (
    <div>{count}{text}</div>
  );
}

/**
 * view
 * @description Help components automatically handle high-level HOC of SCU and memo.
 * @param store: store generated by createStore
 * @param Comp: wrapped component
 * @param deepEqual: propsã€state Depth contrast
 * It will make a deep comparison between props and state and previous props and state.
 * Whether to enable it or not requires developers to measure the performance benefits they can bring.
 * Normally, it is not necessary to enable this feature.
 * Unless you encounter a very heavy component rendering that consumes a lot of performance,
 * it is enabled to reduce the burden of page update rendering through the calculation of JS.
 */
// const TestView = view(store, HookCom);
const TestView = view(store, ClassCom);

function App() {
  const { countAddFun, name } = useStore(store);
  
  return (
  	<>
      <Text/>
      <Count/>
      {/* name data update, will not cause TestView re-render */}
      <TestView/>
      <div>{name}</div>
      <button onClick={() => { store.name = "app"; }}>btn-name</button>
      <button onClick={countAddFun}>btn+</button>
      <button
        onClick={() => {
        	store.count--;
        }}
      >
        btn-
      </button>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [åˆ˜å–„ä¿](https://github.com/lsbFlying)

