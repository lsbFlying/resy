import type { PrimitiveState } from "./types";
import type { StoreOptions, StateCallback } from "./store/types";
import { __DEV__, __REGENERATIVE_SYSTEM_KEY__ } from "./static";
import { toString } from "./utils";

// Check whether the store is generated by Resy's createStore
export const storeErrorHandle = (
  store: unknown,
  fnName: "useStore" | "view" | "connectStore",
) => {
  if (!(store as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    throw new Error(
      `resy's ${
        fnName
      }(...): Expected the 'store' argument should be generated by resy's createStore(...). Instead received: ${
        store
      }.`
    );
  }
};

// Error processing of data update parameters type
export const stateErrorHandle = (
  stateParams: unknown,
  fnName: "setState | syncUpdate" | "createStore",
) => {
  if (toString.call(stateParams) !== "[object Object]") {
    throw new Error(
      `resy's ${fnName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (__DEV__ && (stateParams as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    console.error(
      `Warning: resy's ${fnName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

// Options configuration type error handling of createStore
export const optionsErrorHandle = (
  fnName: "setOptions" | "createStore",
  options?: unknown,
) => {
  const optsExist = options !== undefined;
  const ur = (options as StoreOptions)?.unmountRestore;
  const usm = (options as StoreOptions)?.__useConciseStateMode__;
  if (
    (optsExist && toString.call(options) !== "[object Object]") || (
      optsExist && (
        (typeof ur !== "boolean" && typeof ur !== "undefined")
        || (typeof usm !== "boolean" && typeof usm !== "undefined")
      )
    )
  ) {
    throw new Error(
      `resy's ${fnName}(...): Expected the ${
        fnName === "createStore" ? "last optional" : ""
      } 'options' argument to be a StoreOptions type params. Instead received: ${options}.`
    );
  }
};

// Parameter type error handling of subscribe
export const subscribeErrorHandle = (
  listener: unknown,
  stateKeys?: unknown,
) => {
  if (typeof listener !== "function") {
    throw new Error(
      `resy's subscribe(...): Expected the first optional 'listener' argument to be a function. Instead received: ${listener}.`
    );
  }
  if (stateKeys !== undefined && toString.call(stateKeys) !== "[object Array]") {
    throw new Error(
      `resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. Instead received: ${stateKeys}.`
    );
  }
};

// Callback function type error handling
export const stateCallbackErrorHandle = <S extends PrimitiveState>(callback?: StateCallback<S>) => {
  if (callback !== undefined && typeof callback !== "function") {
    throw new Error(
      `resy's stateCallback(...): Expected the last optional 'callback' argument to be a function. Instead received: ${callback}.`
    );
  }
};

/**
 * @description Error handling when store is set as the prototype of an object
 * Since the receiver object in the proxy
 * that points to the this context object will change with the prototype,
 * such uncontrollable changes can cause incompatibility issues
 * or create discrepancies in understanding with the data returns within the store.
 * Therefore, it is not recommended to perform the uncommon
 * and discordant operation of 'setting the store as the prototype object of certain objects'.
 * 🌟 Note: The discordant issues are mainly caused by the object's property descriptors,
 * such as set and get. Specific examples will not be provided here,
 * for more details, you may refer to the explanations of the receiver in the context of a proxy.
 */
export const protoPointStoreErrorHandle = (receiver: any, store: any) => {
  if (__DEV__ && receiver !== store) {
    console.error(
      "Warning: It is not recommended that store be inherited as a prototype object," +
      " because there is no this pointing to the target object corresponding to the Reflect proxy within store!"
    );
  }
};

/**
 * @description Error handling of options in view
 * @deprecated
 */
export const viewOptionsErrorHandle = (options: unknown) => {
  const { compare, stores } = options as any;
  const compareType = typeof compare;
  const storesType = toString.call(stores);
  if (compareType !== "undefined" && compareType !== "boolean" && compareType !== "function") {
    throw new Error(
      "resy's view(..., options): Expect the compare configuration item of the options parameter"
      + ` in the view to be a boolean value or function. Instead received: ${compare}.`
    );
  }
  // 不是单个store也不是混合store
  if (
    stores !== undefined
    && !(stores as any)?.[__REGENERATIVE_SYSTEM_KEY__]
    && storesType !== "[object Object]"
  ) {
    storeErrorHandle(stores, "view");
  }
  // 不是单个store但却可能是混合store
  if (
    stores !== undefined
    && !(stores as any)?.[__REGENERATIVE_SYSTEM_KEY__]
    && storesType === "[object Object]"
  ) {
    Object.keys(stores as any).forEach(storesKey => {
      storeErrorHandle((stores as any)[storesKey], "view");
    });
  }
};
