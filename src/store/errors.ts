import type { PrimitiveState } from "../types";
import type { StoreOptions, StateCallback } from "./types";
import { __REGENERATIVE_SYSTEM_KEY__ } from "./static";
import { whatsType } from "../utils";
import { __DEV__ } from "../static";

// Check whether the store is generated by Resy's createStore
export const storeErrorHandle = (
  store: unknown,
  fnName: "useStore" | "connectStore",
) => {
  if (__DEV__ && !(store as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    throw new Error(
      `resy's ${
        fnName
      }(...): Expected the 'store' argument should be generated by resy's createStore(...). Instead received: ${
        whatsType(store)
      }.`
    );
  }
};

// Error processing of data update parameters type
export const stateErrorHandle = (
  stateParams: unknown,
  fnName: "setState | syncUpdate" | "createStore",
) => {
  const stateParamsType = whatsType(stateParams);
  if (__DEV__ && stateParamsType !== "Object") {
    throw new Error(
      `resy's ${fnName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (__DEV__ && (stateParams as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    console.error(
      `Warning: resy's ${fnName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

// Options configuration type error handling of createStore
export const optionsErrorHandle = (
  fnName: "setOptions" | "createStore",
  options?: unknown,
) => {
  const optionsType = whatsType(options);
  const optsExist = optionsType !== "Undefined";
  const ur = (options as StoreOptions)?.unmountRestore;
  const usm = (options as StoreOptions)?.__useConciseStateMode__;
  const urType = whatsType(ur);
  const usmType = whatsType(usm);
  if (
    __DEV__ && (optsExist && optionsType !== "Object") || (
      optsExist && (
        (urType !== "Boolean" && urType !== "Undefined")
        || (usmType !== "Boolean" && usmType !== "Undefined")
      )
    )
  ) {
    throw new Error(
      `resy's ${fnName}(...): Expected the ${
        fnName === "createStore" ? "last optional" : ""
      } 'options' argument to be a StoreOptions type params. Instead received: ${
        optionsType
      }.`
    );
  }
};

// Parameter type error handling of subscribe
export const subscribeErrorHandle = (
  listener: unknown,
  stateKeys?: unknown,
) => {
  const listenerType = whatsType(listener);
  const stateKeysType = whatsType(stateKeys);
  if (__DEV__ && listenerType !== "Function") {
    throw new Error(
      `resy's subscribe(...): Expected the first optional 'listener' argument to be a function. Instead received: ${
        listenerType
      }.`
    );
  }
  if (__DEV__ && stateKeysType !== "Undefined" && stateKeysType !== "Array") {
    throw new Error(
      `resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. Instead received: ${
        stateKeysType
      }.`
    );
  }
};

// Callback function type error handling
export const stateCallbackErrorHandle = <S extends PrimitiveState>(callback?: StateCallback<S>) => {
  const callbackType = whatsType(callback);
  if (__DEV__ && callbackType !== "Undefined" && callbackType !== "Function") {
    throw new Error(
      `resy's stateCallback(...): Expected the last optional 'callback' argument to be a function. Instead received: ${
        callbackType
      }.`
    );
  }
};

/**
 * @description It's not recommended to set the store created by createStore as the prototype of some objects,
 * as the store internally hijacks the binding of the this context for function properties
 * (which does not affect arrow functions).
 * This means that for the inherited properties of those set objects,
 * the direction of this will be changed to the hijacked this object specified within the store.
 * The issues caused by such hijacking of this binding also extend to property descriptors like setters and getters.
 * Since the hijacking of this binding for function properties deviates from the native behavior,
 * this could lead to confusion.
 * Therefore, such operations are discouraged!
 */
export const protoPointStoreErrorHandle = (receiver: any, store: any) => {
  if (__DEV__ && receiver !== store) {
    console.error(
      "Warning: It's not recommended to set the store created by createStore as the prototype of some objects" +
      " as the store internally hijacks the binding of the this context for function properties!"
    );
  }
};
