import type { PrimitiveState } from "../types";
import type { StateCallback, InnerStoreOptions } from "./types";
import { __REGENERATIVE_SYSTEM_KEY__ } from "./static";
import { __DEV__ } from "../static";
import { whatsType } from "../utils";

// Check whether the store is generated by Resy's createStore
export const storeErrorProcessing = (
  store: unknown,
  fnName: "useStore" | "connectStore" | "useSubscription",
) => {
  if (__DEV__ && (!(store as any)?.[__REGENERATIVE_SYSTEM_KEY__])) {
    throw new Error(
      `resy's ${fnName}(...): Expected the 'store' argument should be generated by resy's createStore(...). `
      + `Instead received: ${whatsType(store).toLocaleLowerCase()}.`
    );
  }
};

// Error processing of data update parameters type
export const stateErrorProcessing = (params: {
  state: unknown;
  fnName?: "setState、syncUpdate" | "createStore" | "useConciseState" | "defineStore";
  options?: InnerStoreOptions;
}) => {
  const { state, fnName, options } = params;
  const stateType = whatsType(state);
  if (__DEV__ && stateType !== "Object") {
    const fnNameTemp = fnName ?? options?.__functionName__;

    throw new Error(
      `resy's ${fnNameTemp}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
      + ` Instead received: ${stateType.toLocaleLowerCase()}`
    );
  }
  if (__DEV__ && (state as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    console.error(
      "Warning: resy's setState、syncUpdate(...): takes a store of generated by resy's"
      + " createStore that's has no update significance!"
    );
  }
};

// Options configuration type error processing of createStore
export const optionsErrorProcessing = (
  options?: InnerStoreOptions,
) => {
  const optionsType = whatsType(options);
  const optsExist = optionsType !== "Undefined";
  const urType = whatsType(options?.unmountRestore);
  const ucsType = whatsType(options?.__useConciseState__);
  const nsType = whatsType(options?.namespace);
  const emType = whatsType(options?.__enableMacros__);
  const emasType = whatsType(options?.enableMarcoActionStateful);

  if (
    __DEV__ && (
      (
        optsExist && optionsType !== "Object"
      ) || (
        optsExist && optionsType === "Object" && (
          (urType !== "Boolean" && urType !== "Undefined")
          || (ucsType !== "Boolean" && ucsType !== "Undefined")
          || (nsType !== "String" && nsType !== "Undefined")
          || (emType !== "Boolean" && emType !== "Undefined")
          || (emasType !== "Boolean" && emasType !== "Undefined")
        )
      )
    )
  ) {
    throw new Error(
      "resy's createStore(...): Expected the last optional 'options' argument to be a StoreOptions type params."
      + ` Instead received: ${optionsType.toLocaleLowerCase()}.`
    );
  }
};

// Options configuration type error processing of setOptions
export const setOptionsErrorProcessing = (
  options?: InnerStoreOptions,
) => {
  const optionsType = whatsType(options);
  const urType = whatsType(options?.unmountRestore);
  if (
    __DEV__ && (
      optionsType !== "Object" || (
        optionsType === "Object" && urType !== "Boolean"
      )
    )
  ) {
    throw new Error(
      "resy's setOptions(...): Expected the 'options' argument to be an object with a unmountRestore attribute."
      + ` Instead received: ${optionsType.toLocaleLowerCase()}.`
    );
  }
};

// Parameter type error processing of subscribe
export const subscribeErrorProcessing = (
  listener: unknown,
  stateKeys?: unknown,
) => {
  const listenerType = whatsType(listener);
  const stateKeysType = whatsType(stateKeys);
  if (__DEV__ && listenerType !== "Function") {
    throw new Error(
      "resy's subscribe(...): Expected the first optional 'listener' argument to be a function. "
      + `Instead received: ${listenerType.toLocaleLowerCase()}.`
    );
  }
  if (__DEV__ && stateKeysType !== "Undefined" && stateKeysType !== "Array") {
    throw new Error(
      "resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. "
      + `Instead received: ${stateKeysType.toLocaleLowerCase()}.`
    );
  }
};

// Callback function type error processing
export const stateCallbackErrorProcessing = <S extends PrimitiveState>(callback?: StateCallback<S>) => {
  const callbackType = whatsType(callback);
  if (__DEV__ && callbackType !== "Undefined" && callbackType !== "Function") {
    throw new Error(
      "resy's stateCallback(...): Expected the last optional 'callback' argument to be a function. "
      + `Instead received: ${callbackType.toLocaleLowerCase()}.`
    );
  }
};

/**
 * @description It's not recommended to set the store created by createStore as the prototype of some objects,
 * as the store internally hijacks the binding of this context for function properties
 * (which does not affect arrow functions).
 * This means that for the inherited properties of those set objects,
 * the direction of this will be changed to the hijacked this object specified within the store.
 * The issues caused by such hijacking of this binding also extend to property descriptors like setters and getters.
 * Since the hijacking of this binding for function properties deviates from the native behavior,
 * this could lead to confusion.
 * Therefore, such operations are discouraged!
 */
export const protoPointStoreErrorProcessing = (receiver: any, store: any) => {
  if (__DEV__ && receiver !== store) {
    console.error(
      "Warning: It's not recommended to set the store created by createStore as the prototype of some objects" +
      " as the store internally hijacks the binding of this context for function properties!"
    );
  }
};
