import { REGENERATIVE_SYSTEM_KEY } from "./static";
import type { PrimitiveState, MapType, State, ProtectStateType, ProtectActionType } from "./model";

/**
 * map转object
 * @description 解决回调参数如果是map的proxy代理的话无法做扩展运算的问题
 */
export const mapToObject = <S extends PrimitiveState>(map: MapType<S>): S => {
  const object = {} as S;
  for (const [key, value] of map) {
    object[key] = value;
  }
  return object;
};

/**
 * object转map
 * @description 相较于简洁的object.entries方式效率更高
 */
export const objectToMap = <S extends PrimitiveState>(object: S) => {
  const map: MapType<S> = new Map();
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      map.set(key, object[key]);
    }
  }
  return map;
};

// store传的不是由resy本身的createStore创建产生的store的错误处理
export const storeErrorHandle = <S extends PrimitiveState>(store: S, funcName: "useStore" | "view") => {
  if (!store[REGENERATIVE_SYSTEM_KEY as keyof S]) {
    throw new Error(
      `The store parameter of ${funcName} is not a store created by resty's createStore!`
    );
  }
};

// 数据更新参数报错处理
export const stateErrorHandle = <S extends PrimitiveState>(
  stateParams: State<S>,
  funcName: "setState" | "syncUpdate" | "createStore",
) => {
  if (
    Object.prototype.toString.call(stateParams) !== "[object Object]"
    && Object.prototype.toString.call(stateParams) !== "[object Function]"
  ) {
    throw new Error(
      `resy's ${funcName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (
    Object.prototype.toString.call(stateParams) === "[object Object]"
    && (stateParams as Partial<S>)[REGENERATIVE_SYSTEM_KEY as keyof S]
  ) {
    throw new Error(
      `resy's ${funcName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

/**
 * store被设置为某对象的原型的错误处理
 * @description 防止有对象继承了createStore生成的代理对象，
 * 同时initialState属性中又有 "属性描述对象" 的get (getter) 或者set (setter) 存取器 的写法
 * 会导致proxy中的receiver对象指向的this上下文对象变化
 * 使得 get / set 所得到的数据产生非期望的数据值
 * set不会影响数据，因为set之后会从proxy的get走，所以只要控制好get即可保证数据的正确性
 * detail course:
 * 为了杜绝这种复杂的易产生bug的问题，所以直接抛出错误，提醒开发者禁止疑难杂症的代码写法
 * 因为不禁止就要既要解决get又要解决set，两方面综合起来很麻烦，
 * 而且本身这种东西就是容易误导人或者说难以理清的写法，禁止是最好的考量
 */
export const protoPointStoreErrorHandle = (receiver: any, store: any) => {
  if (receiver !== store) {
    console.error(
      "Warning: It is not recommended that store be inherited as a prototype object," +
      " because there is no this pointing to the target object corresponding to the Reflect proxy within store!"
    );
  }
};

/**
 * @description 跟进状态map
 * 相较于直接赋值新值的方式也更快
 */
export const followUpMap = <K, V>(map: Map<K, V>) => {
  const mapTemp: Map<K, V> = new Map();
  map.forEach((value, key) => {
    mapTemp.set(key, value);
  });
  return mapTemp;
};

/**
 * 数据保护处理的异常错误抛出提示处理
 * @description effectState、prevState、nextState以及更新数据的循环引用更新调度的错误处理
 */
export const stateProtectErrorHandle = <S extends PrimitiveState>(
  action: ProtectActionType<S>,
  protectState: ProtectStateType<S>,
) => {
  const { fnName, dataName, callback } = protectState;
  const { key, type } = action;
  throw new Error(
    `${type} the property ${key as string} of ${dataName} is forbidden!
    The parameters given by ${callback ? `${fnName}'s callback` : fnName} are for comparative reference only,
    and cannot be added, deleted or modified.
    In fact, any attribute of ${dataName} is forbidden to operate.
    If you need to manipulate the ${dataName}, you can make an extra deep copy of the ${dataName}.`
  );
};
