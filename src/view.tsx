import React, { memo, useEffect, useState } from "react";
import { STORE_VIEW_MAP_KEY, USE_STORE_KEY } from "./static";
import {
  getLatestStateMap, mapToObject, proxyStateHandler, storeErrorHandle,
  viewStoresStateUpdateHandle, viewStoresToLatestState,
} from "./utils";
import type {
  State, StoreViewMapType, StoreViewMapValue, MapStateToProps, Store, PS,
  Unsubscribe, Stores, EqualStateType, ViewStateMapObjectType, ViewStateMapType,
} from "./model";

/**
 * 自动memo与SCU的高阶HOC
 * @description 自动化规避组件额外re-render的HOC
 * A：通过将Comp组件包裹一层hook，转变成hook组件，从而实现对class组件的支持
 * 本身也自然是支持hook，Comp也可以是hook组件
 *
 * B：view创建初衷：
 * resy本身是为hook而生的，但是还是需要对class组件进行支持
 * class组件依然具有很好的性能与代码健壮性以及读写能力
 *
 * C：view连接了resy生成的store数据，使得Comp组件可以共享store
 * 同时完善了Comp组件自动避免额外re-render，并且特殊的是
 * 它比resy本身自带的规避额外re-render的效果更完善
 * 即如果view包裹的Comp组件即使在其父组件更新渲染了
 * 只要内部使用的数据没有更新，那么它本身不会渲染而产生额外re-render
 *
 * D: 变换柯里化使用方式，优化使用场景的自由度
 *
 * @return (stores?:Store<S>|Stores<S>)=>React.MemoExoticComponent<(props:P)=>JSX.Element>
 *          ➡ 👉 @param stores: store or stores`s store is generated by createStore();
 * @param Comp 被包裹的组件
 * @param equal 是否相等自定义函数
 * 可以自定义深对比props与state和之前的props、state状态
 * 从而来决定是否要更新渲染re-render，类似于memo的propsAreEqual
 *
 * be careful: resy 本身的数据更新在"避免额外冗余的re-render方面"已经做得较为完备了
 * 剩下的就是需要深对比来进一步优化了，但是深对比所获取的效益需要开发人员自行衡量
 * 如果遇到嵌套较深的大型数据对象，一般不建议深对比，
 * 与此同时，如上所说，resy本身即使不使用equal函数参数来优化
 * 也可以取得相当不错的渲染、数据共享等使用效益了
 *
 * 🌟：view更多的是为了兼容class组件，
 * 如果是hook组件，直接使用原生的useMemo然后内部仍然继续使用useStore也是可以的，如下：
 * function SomeHookCom() {
 *   const { ... } = useStore(store);
 *   ...
 * }
 * ... some code start ...
 * {useMemo(() => <SomeHookCom/>, [])}
 * ... some code end ...
 * 这种用法等价于 view(HookCom)() 这样不绑定store的用法
 */
export function view<P extends State = {}, S extends State = {}>(
  // any用于兼容某些HOC导致的类型不合一问题，比如withRouter(低版本的react-router还是存在该HOC)
  // tslint:disable-next-line:variable-name
  Comp: React.ComponentType<MapStateToProps<S, P> | any>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  return (stores?: Store<S> | Stores<S>) => memo((props: P) => {
    /** 需要将innerUseStateMapSet与stateMap放在内部执行，这样每次更新的时候可以得到最新的数据引用与数据stateMap */
    // 引用数据的代理Set（默认无store）
    let innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>> = new Set();
    
    /**
     * @description 给state数据做一个代理，从而让其知晓Comp组件内部使用了哪些数据！
     * 恰巧由于这里的proxy代理，导致在挂载属性数据的时候不能使用扩展运算符，
     * 扩展运算符...会读取所有的属性数据，导致内部关联使用数据属性失去准确性
     * 所以只能挂载到一个集中的属性上，这里选择来props的state属性上
     *
     * be careful: state是一个proxy，这里如果外部数据对象将state作为原型链继承将是无效继承
     */
    const [state, setState] = useState<S | { [key in keyof Stores<S>]: S }>(() => {
      // 需要使用getState获取store内部的即时最新数据值（默认无store）
      let stateMap: ViewStateMapType<S> = new Map<keyof S, S[keyof S]>();
      
      /**
       * 如果是有store的情况则可以通过props.state的方式进行数据渲染及操作
       * 且props.state的方式兼容于函数组件与class组件
       * 但是如果是在class组件中则必须使用props.state的方式
       * 而函数组件则两种方式都可以
       */
      // 先行初始化执行逻辑，并且每次生命周期中只同步执行一次
      if (stores) {
        // 单个Store
        if ((stores as Store<S>)[USE_STORE_KEY as keyof S]) {
          (
            (
              (stores as Store<S>)?.[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
            )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
          )?.();
          
          stateMap = getLatestStateMap(stores as Store<S>);
        } else {
          innerUseStateMapSet = new Map<keyof Stores<S>, Set<keyof S>>();
          // 多个store
          (Object.keys(stores) as (keyof Stores<S>)[]).forEach(storesKey => {
            const storeItem = (stores as Stores<S>)[storesKey] as Store<S>;
            (
              (
                storeItem?.[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
              )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
            )?.();
            
            (stateMap as ViewStateMapObjectType<S>)[storesKey] = getLatestStateMap(storeItem);
            
            (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).set(storesKey, new Set<keyof S>());
          });
        }
      }
      
      if (!stores || (stores as Store<S>)[USE_STORE_KEY as keyof S]) {
        return proxyStateHandler(stateMap as Map<keyof S, S[keyof S]>, innerUseStateMapSet as Set<keyof S>);
      }
      const stateTemp: { [key in keyof Stores<S>]: S } = {} as { [key in keyof Stores<S>]: S };
      Object.keys(stateMap).forEach(stateMapKey => {
        stateTemp[stateMapKey] = proxyStateHandler(
          (stateMap as ViewStateMapObjectType<S>)[stateMapKey],
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).get(stateMapKey) as Set<keyof S>,
        );
      });
      return stateTemp;
    });
    
    useEffect(() => {
      if (!stores) return;
      
      // 因为useEffect是异步的，所以这里执行innerUseStateSet时会有数据而不是空
      const viewConnectStoreSet = new Set<Unsubscribe>();
      
      function handleStoreSubscribe(store: Store<S>, singleStore?: boolean, storesKeyTemp?: keyof Stores<S>) {
        // 在mounted进行一次的store校验
        storeErrorHandle(store);
        
        if (singleStore) {
          innerUseStateMapSet.forEach(() => {
            // 将view关联到store内部的storeRefSet，进行数据生命周期的同步
            viewConnectStoreSet.add(
              (
                (
                  store[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
                ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
              )()
            );
          });
          
          // 刚好巧妙的与resy的订阅监听subscribe结合起来，形成一个reactive更新的包裹容器
          return store.subscribe((
            effectState,
            nextState,
            prevState,
          ) => {
            const effectStateFields = Object.keys(effectState);
            
            if (
              // Comp组件内部使用到的数据属性字段数组，放在触发执行保持内部引用数据最新化
              Array.from(innerUseStateMapSet as Set<keyof S>).some(key => effectStateFields.includes(key as string))
              && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
            ) {
              setState(proxyStateHandler(new Map(Object.entries(nextState)), innerUseStateMapSet as Set<keyof S>));
            }
          });
        } else {
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).forEach((
            _,
            storesKey,
            map,
          ) => {
            (map.get(storesKey) as Set<keyof S>).forEach(() => {
              // 将view关联到每一个store内部的storeRefSet，进行数据生命周期的同步
              viewConnectStoreSet.add(
                (
                  (
                    store[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
                  ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
                )()
              );
            });
          });
          
          return store.subscribe((
            effectState,
            nextState,
            prevState,
          ) => {
            const effectStateFields = Object.keys(effectState);
            const innerUseStateSet = (
              innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>
            ).get(storesKeyTemp as keyof Stores<S>) as Set<keyof S>;
            
            if (
              // Comp组件内部使用到的数据属性字段数组，放在触发执行保持内部引用数据最新化
              Array.from(innerUseStateSet).some(key => effectStateFields.includes(key as string))
              && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
            ) {
              setState(viewStoresStateUpdateHandle(state, innerUseStateSet, nextState, storesKeyTemp));
            }
          });
        }
      }
      
      let unsubscribe: Unsubscribe | Unsubscribe[];
      if ((stores as Store<S>)[USE_STORE_KEY as keyof S]) {
        unsubscribe = handleStoreSubscribe(stores as Store<S>, true);
      } else {
        unsubscribe = [];
        Object.keys(stores).forEach(storesKey => {
          (unsubscribe as Unsubscribe[]).push(handleStoreSubscribe(stores[storesKey], false, storesKey));
        });
      }
      
      return () => {
        typeof unsubscribe === "function"
          ? unsubscribe()
          : unsubscribe.forEach(item => item());
        viewConnectStoreSet.forEach(unsubscribe => unsubscribe());
        innerUseStateMapSet.clear();
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    
    return <Comp {...props} state={state}/>;
  }, equal ? (prevProps: P, nextProps: P) => {
    // props与state的变化可能存在同时变化的情况，但不影响equal的执行
    const latestState = stores
      ? (stores as Store<S>)[USE_STORE_KEY as keyof S]
        ? mapToObject(getLatestStateMap(stores as Store<S>))
        : viewStoresToLatestState(stores)
      : ({} as EqualStateType<S>);
    return equal(
      { props: nextProps, state: latestState },
      { props: prevProps, state: latestState },
    );
  } : undefined);
}
