import React, {
  useEffect, useRef, useMemo, useState, memo, type FunctionComponent,
} from "react";
import {
  SignalStore, SignalsEffectCallback, Destructor,
  Signal, UnwrapSignal, SignalsEffectReturnType, IteratorAbleTypeArgs,
} from "./types";
import type { PrimitiveState } from "../types";
import type {
  InitialState, InnerStoreOptions, StoreOptions, StateRefCounterMapType, Store,
} from "../store/types";
import type { Unsubscribe } from "../subscribe/types";
import {
  __SIGNAL_MARK_AS_COMPUTING__,
  __SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__,
  __SIGNAL_EFFECT_STORE_KEYS_COLLECTING__,
} from "./static";
import { __STATE_REF_COUNTER_KEY__ } from "../store/static";
import { createStore } from "../store";
import { genIterator, getComputedScopeValue } from "./utils";
import { whatsType } from "../utils";
import { signalApiParamsErrorProcessing } from "./errors";

/**
 * createSignals api
 * @description In the signal mode,
 * what needs to be discarded most is the inertial thinking of React's re-render.
 * Once freed from this inertia,
 * combining the signal function allows for the normal use of data in the signal mode.
 * @param initialState
 * @param options
 * @return SignalStore
 */
export const createSignals = <S extends PrimitiveState>(
  initialState?: InitialState<S>,
  options?: StoreOptions,
): SignalStore<S> => {
  return createStore(
    initialState,
    {
      ...options,
      __mode__: "signal",
    } as InnerStoreOptions,
  ) as any as SignalStore<S>;
};

/**
 * signalsEffect api
 * @param effect
 * @param __result__ Internal Use
 */
export const signalsEffect = <T = any, R extends boolean = false>(
  effect: SignalsEffectCallback<T, R>,
  __result__?: R,
): SignalsEffectReturnType<T, R> => {
  signalApiParamsErrorProcessing(effect, "effect", "signalsEffect、useSignalsEffect", __result__);
  __SIGNAL_EFFECT_STORE_KEYS_COLLECTING__.set("collecting", true);
  const resultOrDestructor = effect();
  __SIGNAL_EFFECT_STORE_KEYS_COLLECTING__.set("collecting", false);

  /**
   * @description First,
   * temporarily store the information about the store and key involved in this round's effect,
   * then clear the common `__SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__` data,
   * preparing for the data collection of other effects.
   */
  const signalsEffectStoreKeysCollectorMapTemp = new Map(__SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__);
  __SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__.clear();

  const signalUnsubSet = new Set<Unsubscribe>();

  const subWrap = (store: Store<any>, keys: Set<string>) => {
    const unsub = store.subscribe(() => {
      // Regain control of the flag to prevent hidden data references generated by the condition expression.
      __SIGNAL_EFFECT_STORE_KEYS_COLLECTING__.set("collecting", true);
      effect();
      __SIGNAL_EFFECT_STORE_KEYS_COLLECTING__.set("collecting", false);

      const signalsEffectStoreKeysCollectorMapNew = new Map(__SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__);
      // Immediately clear the common `signalsEffect` collector to prepare for the execution of other `useSignalsEffect` hooks.
      __SIGNAL_EFFECT_STORE_KEYS_COLLECTOR_MAP__.clear();

      signalsEffectStoreKeysCollectorMapNew.forEach((eachKeys, eachStore) => {
        // newly added store
        if (!signalsEffectStoreKeysCollectorMapTemp.has(eachStore)) {
          if (__result__) {
            const stateRefCounter = eachStore[__STATE_REF_COUNTER_KEY__] as StateRefCounterMapType;
            stateRefCounter.set("counter", stateRefCounter.get("counter")! + eachKeys.size);
          }
          // Add the newly added store and its dependencies to the collector.
          signalsEffectStoreKeysCollectorMapTemp.set(eachStore, eachKeys);
          Promise.resolve().then(() => {
            subWrap(eachStore, eachKeys);
          });
        } else {
          let keysAdded = false;
          const latestKeysOfStore = new Set(eachKeys);

          // Find the old dependency key array corresponding to the subscribed store.
          const oldKeys = signalsEffectStoreKeysCollectorMapTemp.get(eachStore)!;
          // Maximizing the collection range of the latest keys.
          oldKeys.forEach(key => {
            latestKeysOfStore.add(key);
          });

          latestKeysOfStore.forEach(key => {
            // newly added key
            if (!oldKeys.has(key)) {
              if (__result__) {
                const stateRefCounter = eachStore[__STATE_REF_COUNTER_KEY__] as StateRefCounterMapType;
                stateRefCounter.set("counter", stateRefCounter.get("counter")! + 1);
              }
              keysAdded = true;
            }
          });

          /**
           * @description If a new data dependency collection
           * is found to be different, cancel the previous subscription and then resubscribe.
           */
          if (keysAdded) {
            /**
             * @description Unsubscribe from the old subscriptions
             * and at the same time update the subscription dependencies
             * in `signalsEffectStoreKeysCollectorMapTemp`
             * to prepare for comparisons with potential new subscriptions that may follow.
             */
            signalUnsubSet.delete(unsub);
            unsub();
            signalsEffectStoreKeysCollectorMapTemp.set(eachStore, latestKeysOfStore);
            /**
             * @description Here, a delay in subscription is required; otherwise,
             * an immediate subscription would lead to an unnecessary execution of
             * the subscription function due to the oldKeys subscriptions from the previous round.
             * This is because the new subscription is generated through a comparison with the new subscription dependencies
             * that arise from the execution of the subscription function from the previous round.
             * Given that the new subscription dependencies will definitely include those from the previous round,
             * the new subscription function here cannot subscribe immediately.
             * Delaying for a bit can avoid the repetitive execution of the subscription function.
             */
            Promise.resolve().then(() => {
              // Using this recursive concept, continuously initiate a new round of subscriptions.
              subWrap(eachStore, latestKeysOfStore);
            });
          }
        }
      });
    }, Array.from(keys));

    signalUnsubSet.add(unsub);
  };

  signalsEffectStoreKeysCollectorMapTemp.forEach((keys, store) => {
    // Processing counters in the context of signal function calls
    if (__result__) {
      const stateRefCounter = store[__STATE_REF_COUNTER_KEY__] as StateRefCounterMapType;
      stateRefCounter.set("counter", stateRefCounter.get("counter")! + keys.size);
    }
    subWrap(store, keys);
  });

  return (
    !__result__
      ? () => {
        (resultOrDestructor as Function)?.();
        signalUnsubSet.forEach(unsub => {
          unsub();
        });
      }
      : {
        result: resultOrDestructor as T,
        destructor: () => {
          signalUnsubSet.forEach(unsub => {
            unsub();
          });
          // Clear the corresponding increase in counters of `storeStateRefCounterMap` generated by subscription dependencies.
          signalsEffectStoreKeysCollectorMapTemp.forEach((keys, store) => {
            const stateRefCounter = store[__STATE_REF_COUNTER_KEY__] as StateRefCounterMapType;
            stateRefCounter.set("counter", stateRefCounter.get("counter")! - keys.size);
          });
        },
      }
  ) as SignalsEffectReturnType<T, R>;
};

/**
 * signalsComputed api
 * @description Processing signal type data can participate in running
 * and return a signal type data result that will not cause the component to re-render.
 */
export const signalsComputed = <T, >(factory: () => T): Signal<UnwrapSignal<T>> => {
  signalApiParamsErrorProcessing(factory, "factory", "signalsComputed、useSignalsComputed");
  const Block = () => {
    /**
     * @description Before officially executing the computed function `factory`,
     * the flag indicating the start of calculation is activated.
     * Primarily used for the chain-like property access calls of signals,
     * to avoid re-entering the proxy conditional branches of signals,
     * preparing to use the original data rather than the signal.
     */
    __SIGNAL_MARK_AS_COMPUTING__.set("computing", true);

    const [stateNode, update] = useState<T>();
    const ref = useRef<Destructor>();

    const initialNode = useMemo(() => {
      const temp = signalsEffect<T, true>(() => {
        __SIGNAL_MARK_AS_COMPUTING__.set("computing", true);
        const result = getComputedScopeValue(factory) as T;
        __SIGNAL_MARK_AS_COMPUTING__.set("computing", false);

        // The clever resolution to the dilemma of updating data states is achieved
        // through the subscriptions inside the effect and the coordinated updates here.
        update(result);

        return result;
      }, true);

      ref.current = temp.destructor;

      return temp.result;
    }, []) as T;

    useEffect(() => () => ref.current?.(), []);

    __SIGNAL_MARK_AS_COMPUTING__.set("computing", false);
    return stateNode ?? initialNode;
  };

  const MemoBlock =  memo(
    Block as FunctionComponent,
    () => true,
  );

  return new Proxy({
    ...<MemoBlock />,
    get value() {
      return getComputedScopeValue(factory);
    },
    get truthy() {
      return Boolean(getComputedScopeValue(factory));
    },
    get falsy() {
      return !getComputedScopeValue(factory);
    },
    typeOf() {
      return whatsType(getComputedScopeValue(factory));
    },
    [Symbol.toPrimitive]() {
      return getComputedScopeValue(factory);
    },
    get [Symbol.toStringTag]() {
      return whatsType(getComputedScopeValue(factory));
    },
    [Symbol.iterator]() {
      return genIterator(getComputedScopeValue(factory) as IteratorAbleTypeArgs);
    },
  }, {
    has(_, prop) {
      return Reflect.has(getComputedScopeValue(factory) as object, prop);
    },
    get(target, prop, receiver) {
      return Reflect.get(target, prop, receiver);
    },
  }) as any as Signal<UnwrapSignal<T>>;
};
