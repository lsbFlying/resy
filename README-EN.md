<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Native、SSR、Mini WeChat Apps (with platform compatible processing, such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=blue&style=flat-square)](https://github.com/lsbFlying/resy/actions/workflows/test.yml)
[![Codecov](https://img.shields.io/codecov/c/github/lsbFlying/resy?style=flat-square)](https://codecov.io/gh/lsbFlying/resy)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)

[简体中文](./README.md) · English
</div>

---

##### version notes
<details>
<summary>changed logs</summary>

🌟`v5.0.0`：<br/>
1. Optimized the code and fixed the bug of incomplete data
of batch triggered subscription changes in the mixed use scenario of setState.
2. Fixed a bug in the way createStore is used as a private data state.

🌟`v4.0.5`：<br/>
Improved the merging and updating of setState and direct updating of all mixed scenarios

🌟`v4.0.4`：<br/>
1. Fixed the bug that the direct update could not be updated in the next round of update batches similar to the useEffect<br/>
2. Optimize the execution of add function in direct update mode<br/>
3. Optimized merge update in the scenario where direct update and setState batch update are mixed

🌟`v4.0.3`：<br/>
1、Fixed the logic of comparing props in view's deepEqual, avoiding the problem of additional update
and rendering due to different reference addresses of props;<br/>
2、Improved and optimized the execution performance of the data subscription listener "subscriber function" code.

🌟`v4.0.2`：<br/>
1. Fixed the processing bug that the logic data of getDerivedStateFromProps of view is empty;<br/>
2. Fixed the bug of update invalidation caused by missing data reference fields
due to possible complex reference logic in the components wrapped in the view;

🌟`v4.0.1`：Fixed the problem of setting the corresponding key value multiple times when using the hookInitialState initialization hook parameter of useStore

🌟`v4.0.0`：resy has been in stable development since v4.0.0,
the API has been named and will not be changed easily.
At the same time, the code tends to be stable and strengthened.
Welcome to use 🌟🌟🌟🌟

</details>

### Features
- It is generated for hook, and the data state is compatible with class components 😎
- Fine grained update, Better avoid redundant re-render 😎
- Easy to use, and the learning cost is almost zero 😎

### Install
```sh
npm i resy

# yarn add resy
```

### Overview
resy requires react version V >= 16.8; resy has five APIs, which are:
- createStore：Create a storage container for global status data
- useStore：Use state data in the state storage container generated from createstore
- setState：Update data
- subscribe：Subscribe and listen for changes in store data generated by createStore
- view：Help components have the ability to "better avoid re-render"

### createStore、useStore
```tsx
import { createStore, useStore } from "resy";

// Data paradigm type interface
type Store = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};
// The generated store can be shared globally and can be imported directly
const store = createStore<Store>(
  {
    count: 0,
    text: "123qwe",
    testObj: { name: "Paul" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  /**
   * The default is true
   * True: the initialization data state is automatically restored when the default module is uninstalled
   * False: the initialization data is not recovered when the module is uninstalled, and the data state is maintained
   * General usage scenarios can be set to true
   * Special use scenarios, such as login information data
   * or the theme data belongs to the global status data and can be set to false
   */
  // false,
);

function App() {
  /**
   * useStore is used for driver update of components, If you use store directly without useStore,
   * Only the pure data can be obtained, and component update and re-rendering cannot be driven.
   */
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useStore(store);

  // Or: const state = useStore(store);
  // state.count; ...etc
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `Age：${item}`)}
    </>
  );
}
```

```tsx
import {useMemo} from "react";
import {createStore, useStore} from "resy";
import {Form} from "antd";
import {FormInstance} from "antd/es/form";
import {Input} from "postcss";

const initialState = {
  count: 123,
	text: "QWE",
};

const store = createStore<{
  count: number;
  text: string;
  form?: FormInstance<{ sortNumber: number }>;
}>(initialState);

function App() {
  /**
   * privatize the store data storage container
   * The following usage methods make the useStore of resy equivalent to the native useState of react in effect
   * const [count, setCount] = useStore(privateStore);
   * const [text, setText] = useStore(privateStore);
   */
  // const privateStore = useMemo(() => createStore(initialState, { privatization: true }), []);
  // Or use store.setState directly without deconstructing the setState
  // const { count, text, setState } = useStore(privateStore);
  /**
   * The useStore also has parameters for initializing data
   * Although createStore already has default data when it passes in initialization default data
   * However, if the default data is initialized, some hooks need to be generated
   * In this case, you need to use the second parameter of useStore ———— initialization data parameter
   */
  const {count, form} = useStore(
    store,
    {
      form: Form.useForm<{ sortNumber: number }>()[0],
    },
  );
  
  function addClick() {
    store.count++;
    form?.setFieldsValue({
      sortNumber: 9999,
    });
  }
  
  return (
    <Form form={form} components={false}>
      <p>{count}</p>
      <button onClick={}>test button</button>
      <br/>
      <Form.Item name="sortNumber">
        <InputNumber/>
      </Form.Item>
    </Form>
  );
}
```

### Direct update
```tsx
import { useStore } from "resy";

function App() {
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useStore(store);
  
  function btn2() {
    /**
     * It should be noted that resy has automatic batch update
     * In addition, the batch update of resy can make up for the version below react v18.
     * In places where react cannot manage, such as promise or setTimeout, batch update also has the effect
     */
    // It can be updated by direct assignment (the simplest update way)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chain update is not allowed, Because resy proxy only maps the data attributes of the first layer
     * For performance reasons, deep recursive proxy is not currently available, The following update methods are invalid
     */
    // store.testObj.name = "Jack";
    // New value assignment required (valid update)
    store.testObj = {
      name: "Jack",
    };
    /**
     * Similarly, arrays are not allowed to update data by directly changing the index value,
     * and the following update way is not valid
     */
    // store.testArr[0] = { age: 7 };
    // Also need new value assignment required (valid update)
    store.testArr = [{ age: 7 }];
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `Age：${item}`)}<br/>
      <button onClick={btn2}>Button2</button>
    </>
  );
}
```

### setState — update state
```tsx
function App() {
  function btnClick() {
    /**
     * 1. The main reason why resy needs setState is that it needs to call back the callback to get the latest updated data
     * As well as the use of setState itself, it has good read-write ability when encoding,
     * The convenience of object data update that supports extension operators and the extensiveness of circular update of function input parameters make setState more robust
     *
     * 2. The batch update of setState is asynchronous just like the direct update,
     * Therefore, the incoming parameter nextState of the callback function is required to obtain the latest data, or the latest data is directly obtained by reading the store inside the callback
     */
    // @example A
    store.setState({
      count: count++,
      text: "456asd",
    }, (nextState) => {
      // nextState：Latest data
      console.log(state.count, state.text);
      // Or now use store. To get the latest data value
      // console.log(store.count, store.text);
    });
    // B way can directly write circular updates in the callback function,
    // which is more convenient for the update of some complex business logic
    // @example B
    // store.setState(() => {
    //   store.count++;
    //   store.text = "456asd";
    // }, (nextState) => {
    //   console.log(nextState.count, nextState.text);
    // });
  }
  
  return (
    <button onClick={btnClick}>Button</button>
  );
}
```

### subscribe — Subscription listening
```tsx
import { useEffect } from "react";
import { useStore } from "resy";

function App() {
  const { count } = useStore(store);
  
  /**
   * Here is an example of a function component
   * If it is a class component, you can use subscribe in componentDidMount
   */
  useEffect(() => {
    /**
     * @description subscribe is also a method of attaching to each store container generated by resy
     *
     * @param listener: Callback function of subscription listening
     * @param stateKey: Subscribe to the change of some data field of a specific store container monitored
     * If it is empty, it will listen to the changes of any data in the store by default.
     * @return Unsubscribe: Return the function of unsubscribing
     */
    const unsubscribe = store.subscribe((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectState：Current changing data
       *   prevState：Data before change
       *   nextState：Data after change
       */
      console.log(effectState, prevState, nextState);
    }, ["count", "text"]);
    
    // unsubscribe();
    return unsubscribe;
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "qweiop123";
  }
	
  function btnClickC() {
    store.count++;
    store.text = "098123kjhkhdfs";
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>ButtonA</button><br/>
      <button onClick={btnClickB}>ButtonB</button><br/>
      <button onClick={btnClickC}>ButtonC</button>
    </>
  );
}
```

### Avoidance re-render of resy its own characteristics
```tsx
import { createStore, useStore } from "resy";

const store = createStore({
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

/**
 * No extra rendering to avoid re-render does not mean - "the parent component renders the child component and still does not render".
 * Re-render refers to:
 * If a and B are at the same level, the data of components at the same level a or sub level a is rendered,
 * it will not lead to the rendering of B components.
 * If the parent component renders the child component, it must render without SCU or useMemo. After all
 */
function App() {
  const { countAddFun } = useStore(store);
  return (
    <>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
    </>
  );
}
```

### view — Better avoid re-render
```markdown
Summary: 
    Compared with resy itself that avoids the feature of additional re-renders
    view processing is more perfect to avoid additional re render.
    
The perfection lies in:
    that is even if the parent component is updated
    As long as view wraps the component itself
    The attribute data of the update reason is not used in the parent component
    Then the components wrapped by view will not be re-render
```
```tsx
/**
 * view
 *
 * @param store - data state storage container generated by resy
 * @param Comp - packaged components
 * @param deepEqual props、state depth contrast
 * It will make a deep comparison between props and state and the previous props and state
 * Whether or not to enable this function requires the developer to measure the performance benefits brought by it.
 * Normally, this function does not need to be enabled
 * Unless the rendering of heavy components is very performance consuming,
 * you can enable JS to reduce the burden of page update rendering
 */
```

```tsx
import { createStore } from "resy";

export type Store = {
  appTestState: string;
  classComTestState: string;
  hookComTestState: string;
  count: number;
  text: string;
  countAddFun: () => void,
};

const store = createStore({
  appTestState: "appTestState",
  classComTestState: "classComTestState",
  hookComTestState: "hookComTestState",
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

export default store;
```

```tsx
// view support for class components
import React from "react";
import { view, MapStateToProps } from "resy";
import store, { Store } from "store";

/**
 * The support mode of view for class components needs to be through props
 * It can be used in the inherited component PureComponent/ComponentMap paradigm of the component
 * Write StateToProps<Store>to use through this.props.state
 * The state data in the store of props
 */
class ClassCom extends React.PureComponent<MapStateToProps<Store>> {
  /**
   * First of all, count and text, hookcomteststate data attributes in the store
   * Cannot affect the re-render of classcom
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of classcom
   * Only the classcomteststate data referenced by classcom itself will affect its rendering
   *
   * That is to say, view has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  render() {
    // view will mount the store data to the new state attribute on props
    const { classComTestState } = this.props.state;
    console.log(classComTestState);
    return (
      <div>{classComTestState}</div>
    );
  }
}

export default view(store, ClassCom);
```

```tsx
// view support for hook components
import React from "react";
import { view, MapStateToProps, useStore } from "resy";
import store, { Store } from "store";

/**
 * View supports Hook components in the same way as class components through props
 * You can also directly use const {...}=useStore (store) in the Hook component without props;
 * The effect of the two is the same, and it is also the most simple and convenient. Here is an example of props
 * In actual development, we can simplify the use and directly use const {...}=useStore (store) in the Hook component;
 */
const HookCom = (props: MapStateToProps<Store>) => {
  // view will mount the store data to the new state attribute on props
  const { hookComTestState } = props.state;
  
  // It can be directly used in the Hook component, which has the same effect as props
  // const { hookComTestState } = useStore(store);
  /**
   * First of all, count and text, classcomteststate data attributes in the store
   * Cannot affect hookcom's render
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of hookcom
   * Only the hookcomteststate data referenced by hookcom itself will affect its rendering
   *
   * That is to say, view has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  console.log(hookComTestState);
  return (
    <div>{hookComTestState}</div>
  );
}

export default view(store, HookCom);
```

```tsx
import React from "react";
import { useStore } from "resy";

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

function App() {
  const {
    appTestState, classComTestState, hookComTestState, countAddFun,
  } = useStore(store);
  
  function appTestClick() {
    store.appTestState = `${Math.random()}~appTestState~`;
  }
  
  function classComTestStateClick() {
    store.classComTestState = `*${Math.random()}classComTestState*`;
  }
  
  function hookComTestStateClick() {
    store.hookComTestState = `!${Math.random()}hookComTestState!`;
  }
  
  return (
    <>
      <div onClick={appTestClick}>{appTestState}</div>
      <div onClick={classComTestStateClick}>{classComTestState}</div>
      <div onClick={hookComTestStateClick}>{hookComTestState}</div>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
      <br/>
      <ClassCom/>
      <HookCom/>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [刘善保](https://github.com/lsbFlying)

