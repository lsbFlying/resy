import React, { memo, useEffect, useState } from "react";
import { STORE_VIEW_MAP_KEY, USE_STORE_KEY } from "./static";
import {
  getLatestStateMap, mapToObject, proxyStateHandler, storeErrorHandle,
  viewStoresStateUpdateHandle, viewStoresToLatestState,
} from "./utils";
import type {
  State, StoreViewMapType, StoreViewMapValue, MapStateToProps, Store, PS,
  Unsubscribe, Stores, EqualStateType, ViewStateMapObjectType, ViewStateMapType,
} from "./model";

/**
 * è‡ªåŠ¨memoä¸SCUçš„é«˜é˜¶HOC
 * @description è‡ªåŠ¨åŒ–è§„é¿ç»„ä»¶é¢å¤–re-renderçš„HOC
 * Aï¼šé€šè¿‡å°†Compç»„ä»¶åŒ…è£¹ä¸€å±‚hookï¼Œè½¬å˜æˆhookç»„ä»¶ï¼Œä»è€Œå®ç°å¯¹classç»„ä»¶çš„æ”¯æŒ
 * æœ¬èº«ä¹Ÿè‡ªç„¶æ˜¯æ”¯æŒhookï¼ŒCompä¹Ÿå¯ä»¥æ˜¯hookç»„ä»¶
 *
 * Bï¼šviewåˆ›å»ºåˆè¡·ï¼š
 * resyæœ¬èº«æ˜¯ä¸ºhookè€Œç”Ÿçš„ï¼Œä½†æ˜¯è¿˜æ˜¯éœ€è¦å¯¹classç»„ä»¶è¿›è¡Œæ”¯æŒ
 * classç»„ä»¶ä¾ç„¶å…·æœ‰å¾ˆå¥½çš„æ€§èƒ½ä¸ä»£ç å¥å£®æ€§ä»¥åŠè¯»å†™èƒ½åŠ›
 *
 * Cï¼šviewè¿æ¥äº†resyç”Ÿæˆçš„storeæ•°æ®ï¼Œä½¿å¾—Compç»„ä»¶å¯ä»¥å…±äº«store
 * åŒæ—¶å®Œå–„äº†Compç»„ä»¶è‡ªåŠ¨é¿å…é¢å¤–re-renderï¼Œå¹¶ä¸”ç‰¹æ®Šçš„æ˜¯
 * å®ƒæ¯”resyæœ¬èº«è‡ªå¸¦çš„è§„é¿é¢å¤–re-renderçš„æ•ˆæœæ›´å®Œå–„
 * å³å¦‚æœviewåŒ…è£¹çš„Compç»„ä»¶å³ä½¿åœ¨å…¶çˆ¶ç»„ä»¶æ›´æ–°æ¸²æŸ“äº†
 * åªè¦å†…éƒ¨ä½¿ç”¨çš„æ•°æ®æ²¡æœ‰æ›´æ–°ï¼Œé‚£ä¹ˆå®ƒæœ¬èº«ä¸ä¼šæ¸²æŸ“è€Œäº§ç”Ÿé¢å¤–re-render
 *
 * D: å˜æ¢æŸ¯é‡ŒåŒ–ä½¿ç”¨æ–¹å¼ï¼Œä¼˜åŒ–ä½¿ç”¨åœºæ™¯çš„è‡ªç”±åº¦
 *
 * @return (stores?:Store<S>|Stores<S>)=>React.MemoExoticComponent<(props:P)=>JSX.Element>
 *          â¡ ğŸ‘‰ @param stores: store or stores`s store is generated by createStore();
 * @param Comp è¢«åŒ…è£¹çš„ç»„ä»¶
 * @param equal æ˜¯å¦ç›¸ç­‰è‡ªå®šä¹‰å‡½æ•°
 * å¯ä»¥è‡ªå®šä¹‰æ·±å¯¹æ¯”propsä¸stateå’Œä¹‹å‰çš„propsã€stateçŠ¶æ€
 * ä»è€Œæ¥å†³å®šæ˜¯å¦è¦æ›´æ–°æ¸²æŸ“re-renderï¼Œç±»ä¼¼äºmemoçš„propsAreEqual
 *
 * be careful: resy æœ¬èº«çš„æ•°æ®æ›´æ–°åœ¨"é¿å…é¢å¤–å†—ä½™çš„re-renderæ–¹é¢"å·²ç»åšå¾—è¾ƒä¸ºå®Œå¤‡äº†
 * å‰©ä¸‹çš„å°±æ˜¯éœ€è¦æ·±å¯¹æ¯”æ¥è¿›ä¸€æ­¥ä¼˜åŒ–äº†ï¼Œä½†æ˜¯æ·±å¯¹æ¯”æ‰€è·å–çš„æ•ˆç›Šéœ€è¦å¼€å‘äººå‘˜è‡ªè¡Œè¡¡é‡
 * å¦‚æœé‡åˆ°åµŒå¥—è¾ƒæ·±çš„å¤§å‹æ•°æ®å¯¹è±¡ï¼Œä¸€èˆ¬ä¸å»ºè®®æ·±å¯¹æ¯”ï¼Œ
 * ä¸æ­¤åŒæ—¶ï¼Œå¦‚ä¸Šæ‰€è¯´ï¼Œresyæœ¬èº«å³ä½¿ä¸ä½¿ç”¨equalå‡½æ•°å‚æ•°æ¥ä¼˜åŒ–
 * ä¹Ÿå¯ä»¥å–å¾—ç›¸å½“ä¸é”™çš„æ¸²æŸ“ã€æ•°æ®å…±äº«ç­‰ä½¿ç”¨æ•ˆç›Šäº†
 *
 * ğŸŒŸï¼šviewæ›´å¤šçš„æ˜¯ä¸ºäº†å…¼å®¹classç»„ä»¶ï¼Œ
 * å¦‚æœæ˜¯hookç»„ä»¶ï¼Œç›´æ¥ä½¿ç”¨åŸç”Ÿçš„useMemoç„¶åå†…éƒ¨ä»ç„¶ç»§ç»­ä½¿ç”¨useStoreä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå¦‚ä¸‹ï¼š
 * function SomeHookCom() {
 *   const { ... } = useStore(store);
 *   ...
 * }
 * ... some code start ...
 * {useMemo(() => <SomeHookCom/>, [])}
 * ... some code end ...
 * è¿™ç§ç”¨æ³•ç­‰ä»·äº view(HookCom)() è¿™æ ·ä¸ç»‘å®šstoreçš„ç”¨æ³•
 */
export function view<P extends State = {}, S extends State = {}>(
  // anyç”¨äºå…¼å®¹æŸäº›HOCå¯¼è‡´çš„ç±»å‹ä¸åˆä¸€é—®é¢˜ï¼Œæ¯”å¦‚withRouter(ä½ç‰ˆæœ¬çš„react-routerè¿˜æ˜¯å­˜åœ¨è¯¥HOC)
  // tslint:disable-next-line:variable-name
  Comp: React.ComponentType<MapStateToProps<S, P> | any>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  return (stores?: Store<S> | Stores<S>) => memo((props: P) => {
    /** éœ€è¦å°†innerUseStateMapSetä¸stateMapæ”¾åœ¨å†…éƒ¨æ‰§è¡Œï¼Œè¿™æ ·æ¯æ¬¡æ›´æ–°çš„æ—¶å€™å¯ä»¥å¾—åˆ°æœ€æ–°çš„æ•°æ®å¼•ç”¨ä¸æ•°æ®stateMap */
    // å¼•ç”¨æ•°æ®çš„ä»£ç†Setï¼ˆé»˜è®¤æ— storeï¼‰
    let innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>> = new Set();
    
    /**
     * @description ç»™stateæ•°æ®åšä¸€ä¸ªä»£ç†ï¼Œä»è€Œè®©å…¶çŸ¥æ™“Compç»„ä»¶å†…éƒ¨ä½¿ç”¨äº†å“ªäº›æ•°æ®ï¼
     * æ°å·§ç”±äºè¿™é‡Œçš„proxyä»£ç†ï¼Œå¯¼è‡´åœ¨æŒ‚è½½å±æ€§æ•°æ®çš„æ—¶å€™ä¸èƒ½ä½¿ç”¨æ‰©å±•è¿ç®—ç¬¦ï¼Œ
     * æ‰©å±•è¿ç®—ç¬¦...ä¼šè¯»å–æ‰€æœ‰çš„å±æ€§æ•°æ®ï¼Œå¯¼è‡´å†…éƒ¨å…³è”ä½¿ç”¨æ•°æ®å±æ€§å¤±å»å‡†ç¡®æ€§
     * æ‰€ä»¥åªèƒ½æŒ‚è½½åˆ°ä¸€ä¸ªé›†ä¸­çš„å±æ€§ä¸Šï¼Œè¿™é‡Œé€‰æ‹©æ¥propsçš„stateå±æ€§ä¸Š
     *
     * be careful: stateæ˜¯ä¸€ä¸ªproxyï¼Œè¿™é‡Œå¦‚æœå¤–éƒ¨æ•°æ®å¯¹è±¡å°†stateä½œä¸ºåŸå‹é“¾ç»§æ‰¿å°†æ˜¯æ— æ•ˆç»§æ‰¿
     */
    const [state, setState] = useState<S | { [key in keyof Stores<S>]: S }>(() => {
      // éœ€è¦ä½¿ç”¨getStateè·å–storeå†…éƒ¨çš„å³æ—¶æœ€æ–°æ•°æ®å€¼ï¼ˆé»˜è®¤æ— storeï¼‰
      let stateMap: ViewStateMapType<S> = new Map<keyof S, S[keyof S]>();
      
      /**
       * å¦‚æœæ˜¯æœ‰storeçš„æƒ…å†µåˆ™å¯ä»¥é€šè¿‡props.stateçš„æ–¹å¼è¿›è¡Œæ•°æ®æ¸²æŸ“åŠæ“ä½œ
       * ä¸”props.stateçš„æ–¹å¼å…¼å®¹äºå‡½æ•°ç»„ä»¶ä¸classç»„ä»¶
       * ä½†æ˜¯å¦‚æœæ˜¯åœ¨classç»„ä»¶ä¸­åˆ™å¿…é¡»ä½¿ç”¨props.stateçš„æ–¹å¼
       * è€Œå‡½æ•°ç»„ä»¶åˆ™ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥
       */
      // å…ˆè¡Œåˆå§‹åŒ–æ‰§è¡Œé€»è¾‘ï¼Œå¹¶ä¸”æ¯æ¬¡ç”Ÿå‘½å‘¨æœŸä¸­åªåŒæ­¥æ‰§è¡Œä¸€æ¬¡
      if (stores) {
        // å•ä¸ªStore
        if ((stores as Store<S>)[USE_STORE_KEY as keyof S]) {
          (
            (
              (stores as Store<S>)?.[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
            )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
          )?.();
          
          stateMap = getLatestStateMap(stores as Store<S>);
        } else {
          innerUseStateMapSet = new Map<keyof Stores<S>, Set<keyof S>>();
          // å¤šä¸ªstore
          (Object.keys(stores) as (keyof Stores<S>)[]).forEach(storesKey => {
            const storeItem = (stores as Stores<S>)[storesKey] as Store<S>;
            (
              (
                storeItem?.[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
              )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
            )?.();
            
            (stateMap as ViewStateMapObjectType<S>)[storesKey] = getLatestStateMap(storeItem);
            
            (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).set(storesKey, new Set<keyof S>());
          });
        }
      }
      
      if (!stores || (stores as Store<S>)[USE_STORE_KEY as keyof S]) {
        return proxyStateHandler(stateMap as Map<keyof S, S[keyof S]>, innerUseStateMapSet as Set<keyof S>);
      }
      const stateTemp: { [key in keyof Stores<S>]: S } = {} as { [key in keyof Stores<S>]: S };
      Object.keys(stateMap).forEach(stateMapKey => {
        stateTemp[stateMapKey] = proxyStateHandler(
          (stateMap as ViewStateMapObjectType<S>)[stateMapKey],
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).get(stateMapKey) as Set<keyof S>,
        );
      });
      return stateTemp;
    });
    
    useEffect(() => {
      if (!stores) return;
      
      // å› ä¸ºuseEffectæ˜¯å¼‚æ­¥çš„ï¼Œæ‰€ä»¥è¿™é‡Œæ‰§è¡ŒinnerUseStateSetæ—¶ä¼šæœ‰æ•°æ®è€Œä¸æ˜¯ç©º
      const viewConnectStoreSet = new Set<Unsubscribe>();
      
      function handleStoreSubscribe(store: Store<S>, singleStore?: boolean, storesKeyTemp?: keyof Stores<S>) {
        // åœ¨mountedè¿›è¡Œä¸€æ¬¡çš„storeæ ¡éªŒ
        storeErrorHandle(store);
        
        if (singleStore) {
          innerUseStateMapSet.forEach(() => {
            // å°†viewå…³è”åˆ°storeå†…éƒ¨çš„storeRefSetï¼Œè¿›è¡Œæ•°æ®ç”Ÿå‘½å‘¨æœŸçš„åŒæ­¥
            viewConnectStoreSet.add(
              (
                (
                  store[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
                ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
              )()
            );
          });
          
          // åˆšå¥½å·§å¦™çš„ä¸resyçš„è®¢é˜…ç›‘å¬subscribeç»“åˆèµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªreactiveæ›´æ–°çš„åŒ…è£¹å®¹å™¨
          return store.subscribe((
            effectState,
            nextState,
            prevState,
          ) => {
            const effectStateFields = Object.keys(effectState);
            
            if (
              // Compç»„ä»¶å†…éƒ¨ä½¿ç”¨åˆ°çš„æ•°æ®å±æ€§å­—æ®µæ•°ç»„ï¼Œæ”¾åœ¨è§¦å‘æ‰§è¡Œä¿æŒå†…éƒ¨å¼•ç”¨æ•°æ®æœ€æ–°åŒ–
              Array.from(innerUseStateMapSet as Set<keyof S>).some(key => effectStateFields.includes(key as string))
              && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
            ) {
              setState(proxyStateHandler(new Map(Object.entries(nextState)), innerUseStateMapSet as Set<keyof S>));
            }
          });
        } else {
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).forEach((
            _,
            storesKey,
            map,
          ) => {
            (map.get(storesKey) as Set<keyof S>).forEach(() => {
              // å°†viewå…³è”åˆ°æ¯ä¸€ä¸ªstoreå†…éƒ¨çš„storeRefSetï¼Œè¿›è¡Œæ•°æ®ç”Ÿå‘½å‘¨æœŸçš„åŒæ­¥
              viewConnectStoreSet.add(
                (
                  (
                    store[STORE_VIEW_MAP_KEY as keyof S] as StoreViewMapType<S>
                  ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
                )()
              );
            });
          });
          
          return store.subscribe((
            effectState,
            nextState,
            prevState,
          ) => {
            const effectStateFields = Object.keys(effectState);
            const innerUseStateSet = (
              innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>
            ).get(storesKeyTemp as keyof Stores<S>) as Set<keyof S>;
            
            if (
              // Compç»„ä»¶å†…éƒ¨ä½¿ç”¨åˆ°çš„æ•°æ®å±æ€§å­—æ®µæ•°ç»„ï¼Œæ”¾åœ¨è§¦å‘æ‰§è¡Œä¿æŒå†…éƒ¨å¼•ç”¨æ•°æ®æœ€æ–°åŒ–
              Array.from(innerUseStateSet).some(key => effectStateFields.includes(key as string))
              && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
            ) {
              setState(viewStoresStateUpdateHandle(state, innerUseStateSet, nextState, storesKeyTemp));
            }
          });
        }
      }
      
      let unsubscribe: Unsubscribe | Unsubscribe[];
      if ((stores as Store<S>)[USE_STORE_KEY as keyof S]) {
        unsubscribe = handleStoreSubscribe(stores as Store<S>, true);
      } else {
        unsubscribe = [];
        Object.keys(stores).forEach(storesKey => {
          (unsubscribe as Unsubscribe[]).push(handleStoreSubscribe(stores[storesKey], false, storesKey));
        });
      }
      
      return () => {
        typeof unsubscribe === "function"
          ? unsubscribe()
          : unsubscribe.forEach(item => item());
        viewConnectStoreSet.forEach(unsubscribe => unsubscribe());
        innerUseStateMapSet.clear();
      };
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    
    return <Comp {...props} state={state}/>;
  }, equal ? (prevProps: P, nextProps: P) => {
    // propsä¸stateçš„å˜åŒ–å¯èƒ½å­˜åœ¨åŒæ—¶å˜åŒ–çš„æƒ…å†µï¼Œä½†ä¸å½±å“equalçš„æ‰§è¡Œ
    const latestState = stores
      ? (stores as Store<S>)[USE_STORE_KEY as keyof S]
        ? mapToObject(getLatestStateMap(stores as Store<S>))
        : viewStoresToLatestState(stores)
      : ({} as EqualStateType<S>);
    return equal(
      { props: nextProps, state: latestState },
      { props: prevProps, state: latestState },
    );
  } : undefined);
}
