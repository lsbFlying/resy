<div align="center">
<h1>resy</h1>

**re**act **s**tate eas**y**

<h3>A simple react state manager</h3>
<h4>Support React Native„ÄÅSSR„ÄÅMini WeChat Apps (with platform compatible processing, such as taro, rax, remax etc)</h4>

[![GitHub license](https://img.shields.io/github/license/lsbFlying/resy?style=flat-square)](https://github.com/lsbFlying/resy/blob/master/LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/lsbFlying/resy/CI?color=blue&style=flat-square)](https://github.com/lsbFlying/resy/actions/workflows/test.yml)
[![Codecov](https://img.shields.io/codecov/c/github/lsbFlying/resy?style=flat-square)](https://codecov.io/gh/lsbFlying/resy)
[![npm type definitions](https://img.shields.io/npm/types/typescript?color=orange&style=flat-square)](https://github.com/lsbFlying/resy/blob/master/src/index.ts)
[![npm](https://img.shields.io/npm/v/resy?color=blue&style=flat-square)](https://www.npmjs.com/package/resy)
[![npm bundle size](https://img.shields.io/bundlephobia/minzip/resy?color=brightgreen&style=flat-square)](https://bundlephobia.com/result?p=resy)

[ÁÆÄ‰Ωì‰∏≠Êñá](./README.md) ¬∑ English
</div>

---

##### notes
```markdown
resy has been in stable development since v4.0.0
The API has been named and will not be changed easily.
At the same time,
the code tends to be stable and strengthened after 57 versions of the code.
You are welcome to use it freely üåüüåüüåüüåü
```

### Features
- Support hook components and class components üòé
- Fine grained update, Better avoid redundant re-render üòé
- Easy to use, and the learning cost is almost zero üòé

### Install
```sh
npm i resy

# yarn add resy
```

### Overview
resy requires react version V >= 16.8; resy has five APIs, which are:
- createStoreÔºöCreate a storage container for global status data
- useStoreÔºöUse state data in the state storage container generated from createstore
- setStateÔºöUpdate data
- subscribeÔºöSubscribe and listen for changes in store data generated by createStore
- viewÔºöHelp components have the ability to "better avoid re-render"

### createStore„ÄÅuseStore
```tsx
import { createStore, useStore } from "resy";

// Data paradigm type interface
type Store = {
  count: number;
  text: string;
  testObj: { name: string };
  testArr: { age: number }[];
  testFun: () => void;
};
// The generated store can be shared globally and can be imported directly
const store = createStore<Store>(
  {
    count: 0,
    text: "123qwe",
    testObj: { name: "Paul" },
    testArr: [{age: 12}, { age: 16 }],
    testFun: () => {
      store.count++;
      console.log("testFun");
    },
  },
  /**
   * The default is true
   * True: the initialization data state is automatically restored when the default module is uninstalled
   * False: the initialization data is not recovered when the module is uninstalled, and the data state is maintained
   * General usage scenarios can be set to true
   * Special use scenarios, such as login information data
   * or the theme data belongs to the global status data and can be set to false
   */
  // false,
);

function App() {
  /**
   * useStore is used for driver update of components, If you use store directly without useStore,
   * Only the pure data can be obtained, and component update and re-rendering cannot be driven.
   */
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useStore(store);

  // Or: const state = useStore(store);
  // state.count; ...etc
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}
    </>
  );
}
```

```tsx
import { useMemo } from "react";
import { createStore, useStore } from "resy";

const initialState = {
  count: 123,
  text: "test text",
  obj: {
    name: "QWE",
  }
};

const store = createStore(initialState);

function App() {
  /**
   * privatize the store data storage container
   * The following usage methods make the useStore of resy equivalent to the native useState of react in effect
   */
  // const store = useMemo(() => createStore(initialState), []);
  // const { count } = useStore(store);
  
  /**
   * Or use the initialization data parameters of useStore
   * It can also achieve the effect of the above writing method, and the effect is more
   */
  const { count, obj } = useStore(store, { count: 0, obj: { name: "ASD" } });
  
  function addClick() {
    store.count++;
  }
  
  return (
    <>
      <p>{count}Ôºåobject nameÔºö{obj.name}</p>
      <button onClick={}>test button</button><br/>
    </>
  );
}
```

### Direct update
```tsx
import { useStore } from "resy";

function App() {
  const {
    count, text, testObj: { name }, testArr, testFun,
  } = useStore(store);
  
  function btn2() {
    /**
     * It should be noted that resy has automatic batch update
     * In addition, the batch update of resy can make up for the version below react v18.
     * In places where react cannot manage, such as promise or setTimeout, batch update also has the effect
     */
    // It can be updated by direct assignment (the simplest update way)
    store.count++;
    store.text = "456asd";
    /**
     * Direct attribute chain update is not allowed, Because resy proxy only maps the data attributes of the first layer
     * For performance reasons, deep recursive proxy is not currently available, The following update methods are invalid
     */
    // store.testObj.name = "Jack";
    // New value assignment required (valid update)
    store.testObj = {
      name: "Jack",
    };
    /**
     * Similarly, arrays are not allowed to update data by directly changing the index value,
     * and the following update way is not valid
     */
    // store.testArr[0] = { age: 7 };
    // Also need new value assignment required (valid update)
    store.testArr = [{ age: 7 }];
  }
  
  return (
    <>
      <p>{count}</p>
      <p>{text}</p>
      <p>{name}</p>
      <button onClick={testFun}>Test Button</button><br/>
      {testArr.map(item => `AgeÔºö${item}`)}<br/>
      <button onClick={btn2}>Button2</button>
    </>
  );
}
```

### setState ‚Äî update state
```tsx
function App() {
  function btnClick() {
    /**
     * 1„ÄÅ The main reason why resy needs setState is that it needs the callback function of setState
     * The parameters of its callback function are the latest data, or the latest data can be obtained through store. In the callback function
     * Because the update of resy is asynchronous, the callback of setState is required when the data needs to be obtained synchronously
     * It is equivalent to the callback of this.setState in the class component
     * Second, the use of setState itself has good reading and writing ability during coding
     * The convenience of updating object data and the ability to directly write cyclic updates make setState have stronger vitality
     * At the same time, it also makes up for the defect that the latest data cannot be obtained immediately after the hook data status is asynchronously updated
     *
     * 2„ÄÅsetState is a method of attaching to each store container generated by resy
     */
    // @example A
    store.setState({
      count: count++,
      text: "456asd",
    }, (state) => {
      // stateÔºöLatest data value
      // It can be understood that state is this in the callback function of "this.setState" state
      // At the same time, this also makes up for:
      // In the hook component, the latest data can only be obtained through useeffect after setState
      console.log(state.count, state.text);
      // Or use store. To get the latest data value
      // console.log(store.count, store.text);
    });
    // B way can directly write circular updates in the callback function,
    // which is more convenient for the update of some complex business logic
    // @example B
    // store.setState(() => {
    //   store.count++;
    //   store.text = "456asd";
    // }, (state) => {
    //   console.log(state.count, state.text);
    // });
  }
  
  return (
    <button onClick={btnClick}>Button</button>
  );
}
```

### subscribe ‚Äî Subscription listening
```tsx
import { useEffect } from "react";
import { useStore } from "resy";

function App() {
  const { count } = useStore(store);
  
  /**
   * Here is an example of a function component
   * If it is a class component, you can use subscribe in componentDidMount
   */
  useEffect(() => {
    /**
     * @description subscribe is also a method of attaching to each store container generated by resy
     *
     * @param listener: Callback function of subscription listening
     * @param stateKey: Subscribe to the change of some data field of a specific store container monitored
     * If it is empty, it will listen to the changes of any data in the store by default.
     * @return Unsubscribe: Return the function of unsubscribing
     */
    const unsubscribe = store.subscribe((
      effectState, prevState, nextState,
    ) => {
      /**
       * effectStateÔºöCurrent changing data
       *   prevStateÔºöData before change
       *   nextStateÔºöData after change
       */
      console.log(effectState, prevState, nextState);
    }, ["count", "text"]);
    
    // unsubscribe();
    return unsubscribe;
  }, []);
  
  function btnClickA() {
    store.count++;
  }
	
  function btnClickB() {
    store.text = "qweiop123";
  }
	
  function btnClickC() {
    store.count++;
    store.text = "098123kjhkhdfs";
  }
  
  return (
    <>
      <p>{count}</p>
      <button onClick={btnClickA}>ButtonA</button><br/>
      <button onClick={btnClickB}>ButtonB</button><br/>
      <button onClick={btnClickC}>ButtonC</button>
    </>
  );
}
```

### Avoidance re-render of resy its own characteristics
```tsx
import { createStore, useStore } from "resy";

const store = createStore({
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

/**
 * No extra rendering to avoid re-render does not mean - "the parent component renders the child component and still does not render".
 * Re-render refers to:
 * If a and B are at the same level, the data of components at the same level a or sub level a is rendered,
 * it will not lead to the rendering of B components.
 * If the parent component renders the child component, it must render without SCU or useMemo. After all
 */
function App() {
  const { countAddFun } = useStore(store);
  return (
    <>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
    </>
  );
}
```

### view ‚Äî Better avoid re-render
```markdown
Summary: compared with resy's own characteristics, re-render
    view handles circumvented re-render more perfectly
    The perfection lies in:
    that is even if the parent component is updated
    As long as view wraps the component itself
    The attribute data of the update reason is not used in the parent component
    Then the components wrapped by view will not be re-render
```

```tsx
/**
 * view
 *
 * @param store - data state storage container generated by resy
 * @param Comp - packaged components
 * @param deepEqual - depth contrast
 * About the deepEqual parameter, because props belong to the props attribute passed in from the outside of the view converted component
 * Therefore, it is independent of the internal data status update control of view and more dependent on the external control
 * Whether to enable requires the developer to measure the performance benefits
 */
import { createStore } from "resy";

export type Store = {
  appTestState: string;
  classComTestState: string;
  hookComTestState: string;
  count: number;
  text: string;
  countAddFun: () => void,
};

const store = createStore({
  appTestState: "appTestState",
  classComTestState: "classComTestState",
  hookComTestState: "hookComTestState",
  count: 123,
  text: "123qwe",
  countAddFun: () => {
    store.count++;
  },
});

export default store;
```

```tsx
// view support for class components
import React from "react";
import { view, MapStateToProps } from "resy";
import store, { Store } from "store";

class ClassCom extends React.PureComponent<MapStateToProps<Store>> {
  /**
   * First of all, count and text, hookcomteststate data attributes in the store
   * Cannot affect the re-render of classcom
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of classcom
   * Only the classcomteststate data referenced by classcom itself will affect its rendering
   *
   * That is to say, view has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  render() {
    // view will mount the store data to the new state attribute on props
    const { classComTestState } = this.props.state;
    console.log(classComTestState);
    return (
      <div>{classComTestState}</div>
    );
  }
}

export default view(store, ClassCom);
```

```tsx
// view support for hook components
import React from "react";
import { view, MapStateToProps } from "resy";
import store, { Store } from "store";

const HookCom = (props: MapStateToProps<Store>) => {
  // view will mount the store data to the new state attribute on props
  const { hookComTestState } = props.state;
  /**
   * First of all, count and text, classcomteststate data attributes in the store
   * Cannot affect hookcom's render
   * Secondly, the change of the appteststate of the parent component app cannot affect the renewal of hookcom
   * Only the hookcomteststate data referenced by hookcom itself will affect its rendering
   *
   * That is to say, view has the effect of avoiding re-render
   * It is more perfect than resy's own effect of avoiding re-render
   */
  console.log(hookComTestState);
  return (
    <div>{hookComTestState}</div>
  );
}

export default view(store, HookCom);
```

```tsx
import React from "react";
import { useStore } from "resy";

// The change of count data state will not cause the re-render of text
function Text() {
  const { text } = useStore(store);
  return <p>{text}</p>;
}

// Text the change of data status will not cause the re-render of count
function Count() {
  const { count } = useStore(store);
  return <p>{count}</p>;
}

function App() {
  const {
    appTestState, classComTestState, hookComTestState, countAddFun,
  } = useStore(store);
  
  function appTestClick() {
    store.appTestState = `${Math.random()}~appTestState~`;
  }
  
  function classComTestStateClick() {
    store.classComTestState = `*${Math.random()}classComTestState*`;
  }
  
  function hookComTestStateClick() {
    store.hookComTestState = `!${Math.random()}hookComTestState!`;
  }
  
  return (
    <>
      <div onClick={appTestClick}>{appTestState}</div>
      <div onClick={classComTestStateClick}>{classComTestState}</div>
      <div onClick={hookComTestStateClick}>{hookComTestState}</div>
      <Text/>
      <Count/>
      <button onClick={countAddFun}>Button +</button>
      <button
        onClick={() => {
          store.count--;
        }}
      >
        Button -
      </button>
      <br/>
      <ClassCom/>
      <HookCom/>
    </>
  );
}
```

### License
[MIT License](https://github.com/lsbFlying/resy/blob/master/LICENSE) (c) [ÂàòÂñÑ‰øù](https://github.com/lsbFlying)

