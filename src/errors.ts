import type { PrimitiveState } from "./types";
import type { StoreOptions, StateCallback } from "./store/types";
import { __REGENERATIVE_SYSTEM_KEY__ } from "./store/static";
import { __DEV__ } from "./static";
import { whatsType } from "./utils";

// Check whether the store is generated by Resy's createStore
export const storeErrorProcessing = (
  store: unknown,
  fnName: "useStore" | "connectStore",
) => {
  if (__DEV__ && !(store as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    throw new Error(
      `resy's ${
        fnName
      }(...): Expected the 'store' argument should be generated by resy's createStore(...). Instead received: ${
        whatsType(store)
      }.`
    );
  }
};

// Error processing of data update parameters type
export const stateErrorProcessing = (
  stateParams: unknown,
  fnName: "setState | syncUpdate" | "createStore",
) => {
  const stateParamsType = whatsType(stateParams);
  if (__DEV__ && stateParamsType !== "Object") {
    throw new Error(
      `resy's ${fnName}(...): takes an object of state variables to update or`
      + " a function which returns an object of state variables."
    );
  }
  if (__DEV__ && (stateParams as any)?.[__REGENERATIVE_SYSTEM_KEY__]) {
    console.error(
      `Warning: resy's ${fnName}(...): takes a store of generated by resy's createStore that's has no update significance!`
    );
  }
};

// Options configuration type error processing of createStore
export const optionsErrorProcessing = (
  options?: unknown,
) => {
  const optionsType = whatsType(options);
  const optsExist = optionsType !== "Undefined";
  const urType = whatsType((options as StoreOptions)?.unmountRestore);
  const ucsmType = whatsType((options as StoreOptions)?.__useConciseStateMode__);
  if (
    __DEV__ && (
      (
        optsExist && optionsType !== "Object"
      ) || (
        optsExist && optionsType === "Object" && (
          (urType !== "Boolean" && urType !== "Undefined")
          || (ucsmType !== "Boolean" && ucsmType !== "Undefined")
        )
      )
    )
  ) {
    throw new Error(
      "resy's createStore(...): Expected the last optional 'options' argument to be a StoreOptions type params."
      + ` Instead received: ${
        optionsType
      }.`
    );
  }
};

// Options configuration type error processing of setOptions
export const setOptionsErrorProcessing = (
  options?: unknown,
) => {
  const optionsType = whatsType(options);
  const urType = whatsType((options as StoreOptions)?.unmountRestore);
  if (
    __DEV__ && (
      optionsType !== "Object" || (
        optionsType === "Object" && urType !== "Boolean"
      )
    )
  ) {
    throw new Error(
      "resy's setOptions(...): Expected the 'options' argument to be an object with a unmountRestore attribute."
      + ` Instead received: ${optionsType}.`
    );
  }
};

// Parameter type error processing of subscribe
export const subscribeErrorProcessing = (
  listener: unknown,
  stateKeys?: unknown,
) => {
  const listenerType = whatsType(listener);
  const stateKeysType = whatsType(stateKeys);
  if (__DEV__ && listenerType !== "Function") {
    throw new Error(
      `resy's subscribe(...): Expected the first optional 'listener' argument to be a function. Instead received: ${
        listenerType
      }.`
    );
  }
  if (__DEV__ && stateKeysType !== "Undefined" && stateKeysType !== "Array") {
    throw new Error(
      `resy's subscribe(...): Expected the last optional 'stateKeys' argument to be a array. Instead received: ${
        stateKeysType
      }.`
    );
  }
};

// Callback function type error processing
export const stateCallbackErrorProcessing = <S extends PrimitiveState>(callback?: StateCallback<S>) => {
  const callbackType = whatsType(callback);
  if (__DEV__ && callbackType !== "Undefined" && callbackType !== "Function") {
    throw new Error(
      `resy's stateCallback(...): Expected the last optional 'callback' argument to be a function. Instead received: ${
        callbackType
      }.`
    );
  }
};

/**
 * @description It's not recommended to set the store created by createStore as the prototype of some objects,
 * as the store internally hijacks the binding of this context for function properties
 * (which does not affect arrow functions).
 * This means that for the inherited properties of those set objects,
 * the direction of this will be changed to the hijacked this object specified within the store.
 * The issues caused by such hijacking of this binding also extend to property descriptors like setters and getters.
 * Since the hijacking of this binding for function properties deviates from the native behavior,
 * this could lead to confusion.
 * Therefore, such operations are discouraged!
 */
export const protoPointStoreErrorProcessing = (receiver: any, store: any) => {
  if (__DEV__ && receiver !== store) {
    console.error(
      "Warning: It's not recommended to set the store created by createStore as the prototype of some objects" +
      " as the store internally hijacks the binding of this context for function properties!"
    );
  }
};
