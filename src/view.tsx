import React, { Dispatch, memo, SetStateAction, useEffect, useState } from "react";
import { VIEW_CONNECT_STORE_KEY, RESY_ID } from "./static";
import { mapToObject, storeErrorHandle } from "./utils";
import {
  getLatestStateMap, stateRefByProxyHandle,
  viewStoresStateUpdateHandle, viewStoresToLatestState,
} from "./reduce";
import type {
  PrimitiveState, StoreViewMapType, StoreViewMapValue, MapStateToProps, Store, PS, Unsubscribe,
  Stores, ObjectMapType, ViewStateMapType, ValueOf, MapType, ObjectType,
} from "./model";

/**
 * è‡ªåŠ¨memoä¸SCUçš„é«˜é˜¶HOC
 * @description å®ƒä¼šè‡ªåŠ¨åŒ–è§„é¿ç»„ä»¶é¢å¤–å¤šä½™çš„re-render
 *
 * @return (stores?:Store<S>|Stores<S>)=>React.MemoExoticComponent<(props:P)=>JSX.Element>
 *          â¡ ğŸ‘‰ @param stores: store or stores`s store is generated by createStore();
 * @param Comp è¢«åŒ…è£¹çš„ç»„ä»¶
 * @param equal æ˜¯å¦ç›¸ç­‰è‡ªå®šä¹‰å‡½æ•°
 */
export function view<P extends PrimitiveState = {}, S extends PrimitiveState = {}>(
  // anyç”¨äºå…¼å®¹æŸäº›HOCå¯¼è‡´çš„ç±»å‹ä¸åˆä¸€é—®é¢˜ï¼Œæ¯”å¦‚withRouter(ä½ç‰ˆæœ¬çš„react-routerè¿˜æ˜¯å­˜åœ¨è¯¥HOC)
  // tslint:disable-next-line:variable-name
  Comp: React.ComponentType<MapStateToProps<S, P> | any>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  return (stores?: Store<S> | Stores<S>) => memo((props: P) => {
    /** éœ€è¦å°†innerUseStateMapSetä¸stateMapæ”¾åœ¨å†…éƒ¨æ‰§è¡Œï¼Œè¿™æ ·æ¯æ¬¡æ›´æ–°çš„æ—¶å€™å¯ä»¥å¾—åˆ°æœ€æ–°çš„æ•°æ®å¼•ç”¨ä¸æ•°æ®stateMap */
    // å¼•ç”¨æ•°æ®çš„ä»£ç†Setï¼ˆé»˜è®¤æ— storeï¼‰
    let innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>> = new Set();
    
    /**
     * @description ç»™stateæ•°æ®åšä¸€ä¸ªä»£ç†ï¼Œä»è€Œè®©å…¶çŸ¥æ™“Compç»„ä»¶å†…éƒ¨ä½¿ç”¨äº†å“ªäº›æ•°æ®ï¼
     * æ°å·§ç”±äºè¿™é‡Œçš„proxyä»£ç†ï¼Œå¯¼è‡´åœ¨æŒ‚è½½å±æ€§æ•°æ®çš„æ—¶å€™ä¸èƒ½ä½¿ç”¨æ‰©å±•è¿ç®—ç¬¦ï¼Œ
     * æ‰©å±•è¿ç®—ç¬¦...ä¼šè¯»å–æ‰€æœ‰çš„å±æ€§æ•°æ®ï¼Œå¯¼è‡´å†…éƒ¨å…³è”ä½¿ç”¨æ•°æ®å±æ€§å¤±å»å‡†ç¡®æ€§
     * æ‰€ä»¥åªèƒ½æŒ‚è½½åˆ°ä¸€ä¸ªé›†ä¸­çš„å±æ€§ä¸Šï¼Œè¿™é‡Œé€‰æ‹©æ¥propsçš„stateå±æ€§ä¸Š
     *
     * be careful: stateæ˜¯ä¸€ä¸ªproxyï¼Œè¿™é‡Œå¦‚æœå¤–éƒ¨æ•°æ®å¯¹è±¡å°†stateä½œä¸ºåŸå‹é“¾ç»§æ‰¿å°†æ˜¯æ— æ•ˆç»§æ‰¿
     */
    const [state, setState] = useState<S | { [key in keyof Stores<S>]: S }>(() => {
      // éœ€è¦ä½¿ç”¨getStateè·å–storeå†…éƒ¨çš„å³æ—¶æœ€æ–°æ•°æ®å€¼ï¼ˆé»˜è®¤æ— storeï¼‰
      let stateMap: ViewStateMapType<S> = new Map() as MapType<S>;
      
      /**
       * å¦‚æœæ˜¯æœ‰storeçš„æƒ…å†µåˆ™å¯ä»¥é€šè¿‡props.stateçš„æ–¹å¼è¿›è¡Œæ•°æ®æ¸²æŸ“åŠæ“ä½œ
       * ä¸”props.stateçš„æ–¹å¼å…¼å®¹äºå‡½æ•°ç»„ä»¶ä¸classç»„ä»¶
       * ä½†æ˜¯å¦‚æœæ˜¯åœ¨classç»„ä»¶ä¸­åˆ™å¿…é¡»ä½¿ç”¨props.stateçš„æ–¹å¼
       * è€Œå‡½æ•°ç»„ä»¶åˆ™ä¸¤ç§æ–¹å¼éƒ½å¯ä»¥
       */
      // å…ˆè¡Œåˆå§‹åŒ–æ‰§è¡Œé€»è¾‘ï¼Œå¹¶ä¸”æ¯æ¬¡ç”Ÿå‘½å‘¨æœŸä¸­åªåŒæ­¥æ‰§è¡Œä¸€æ¬¡
      if (stores) {
        // å•ä¸ªStore
        if ((stores as Store<S>)[RESY_ID as keyof S]) {
          (
            (
              (stores as Store<S>)?.[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
            )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
          )?.();
          
          stateMap = getLatestStateMap(stores as Store<S>);
        } else {
          // å¤šä¸ªstore
          innerUseStateMapSet = new Map<keyof Stores<S>, Set<keyof S>>();
          (Object.keys(stores) as (keyof Stores<S>)[]).forEach(storesKey => {
            const storeItem = (stores as Stores<S>)[storesKey] as Store<S>;
            
            (
              (
                storeItem?.[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
              )?.get("viewInitialReset") as StoreViewMapValue<S>["viewInitialReset"]
            )?.();
            
            (stateMap as ObjectMapType<S>)[storesKey] = getLatestStateMap(storeItem);
            
            (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).set(storesKey, new Set<keyof S>());
          });
        }
      }
      
      // å•store æˆ– æ— store
      if (!stores || (stores as Store<S>)[RESY_ID as keyof S]) {
        return stateRefByProxyHandle(stateMap as MapType<S>, innerUseStateMapSet as Set<keyof S>);
      }
      // å¤šstore
      const stateTemp = {} as ObjectType<S>;
      Object.keys(stateMap).forEach((stateMapKey: keyof S) => {
        stateTemp[stateMapKey] = stateRefByProxyHandle<ValueOf<S>>(
          (stateMap as ObjectMapType<S>)[stateMapKey],
          (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).get(stateMapKey) as Set<keyof S>,
        );
      });
      return stateTemp;
    });
    
    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(() => mountedHandle(innerUseStateMapSet, state, setState, props, stores, equal), []);
    
    return <Comp {...props} state={state}/>;
  }, equal ? (prevProps: P, nextProps: P) => {
    // propsä¸stateçš„å˜åŒ–å¯èƒ½å­˜åœ¨åŒæ—¶å˜åŒ–çš„æƒ…å†µï¼Œä½†ä¸å½±å“equalçš„æ‰§è¡Œ
    const latestState = stores
      ? (stores as Store<S>)[RESY_ID as keyof S]
        ? mapToObject(getLatestStateMap(stores as Store<S>))
        : viewStoresToLatestState(stores)
      : ({} as S);
    return equal(
      { props: nextProps, state: latestState },
      { props: prevProps, state: latestState },
    );
  } : undefined);
}

// ç»„ä»¶åŠ è½½å®Œæˆåçš„å¤„ç†
function mountedHandle<S extends PrimitiveState, P extends PrimitiveState = {}>(
  innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>>,
  state: S | { [key in keyof Stores<S>]: S },
  setState: Dispatch<SetStateAction<S | { [key in keyof Stores<S>]: S }>>,
  props: P,
  stores?: Store<S> | Stores<S>,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
) {
  if (!stores) return;
  
  // å› ä¸ºuseEffectæ˜¯å¼‚æ­¥çš„ï¼Œæ‰€ä»¥åç»­è®¿é—® innerUseStateMapSet æ—¶ä¼šæœ‰æ•°æ®è€Œä¸æ˜¯ç©º
  const viewConnectStoreSet = new Set<Unsubscribe>();
  
  let unsubscribe: Unsubscribe | Unsubscribe[];
  // å•store
  if ((stores as Store<S>)[RESY_ID as keyof S]) {
    unsubscribe = handleStoreSubscribe(
      stores as Store<S>,
      innerUseStateMapSet,
      viewConnectStoreSet,
      state,
      setState,
      props,
      equal,
      true,
    );
  } else {
    unsubscribe = [];
    Object.keys(stores).forEach(storesKey => {
      (unsubscribe as Unsubscribe[]).push(handleStoreSubscribe(
        stores[storesKey],
        innerUseStateMapSet,
        viewConnectStoreSet,
        state,
        setState,
        props,
        equal,
        false,
        storesKey,
      ));
    });
  }
  
  return () => {
    typeof unsubscribe === "function" ? unsubscribe() : unsubscribe.forEach(item => item());
    viewConnectStoreSet.forEach(unsubscribe => unsubscribe());
    innerUseStateMapSet.clear();
  };
}

// å¤„ç†å•ä¸ª/å¤šä¸ªstoreçš„æ•°æ®è®¢é˜…ç›‘å¬
function handleStoreSubscribe<S extends PrimitiveState, P extends PrimitiveState = {}>(
  store: Store<S>,
  innerUseStateMapSet: Set<keyof S> | Map<keyof Stores<S>, Set<keyof S>>,
  viewConnectStoreSet: Set<Unsubscribe>,
  state: S | { [key in keyof Stores<S>]: S },
  setState: Dispatch<SetStateAction<S | { [key in keyof Stores<S>]: S }>>,
  props: P,
  equal?: (next: PS<P, S>, prev: PS<P, S>) => boolean,
  singleStore?: boolean,
  storesKeyTemp?: keyof Stores<S>,
) {
  // åœ¨mountedè¿›è¡Œä¸€æ¬¡çš„storeæ ¡éªŒ
  storeErrorHandle(store, "view");
  
  if (singleStore) {
    innerUseStateMapSet.forEach(() => {
      // å°†viewå…³è”åˆ°storeå†…éƒ¨çš„storeStateRefSetï¼Œè¿›è¡Œæ•°æ®ç”Ÿå‘½å‘¨æœŸçš„åŒæ­¥
      viewConnectStoreSet.add(
        (
          (
            store[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
          ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
        )()
      );
    });
    
    // åˆšå¥½å·§å¦™çš„ä¸resyçš„è®¢é˜…ç›‘å¬subscribeç»“åˆèµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªreactiveæ›´æ–°çš„åŒ…è£¹å®¹å™¨
    return store.subscribe((
      effectState,
      nextState,
      prevState,
    ) => {
      const effectStateFields = Object.keys(effectState);
      
      if (
        // Compç»„ä»¶å†…éƒ¨ä½¿ç”¨åˆ°çš„æ•°æ®å±æ€§å­—æ®µæ•°ç»„ï¼Œæ”¾åœ¨è§¦å‘æ‰§è¡Œä¿æŒå†…éƒ¨å¼•ç”¨æ•°æ®æœ€æ–°åŒ–
        Array.from(innerUseStateMapSet as Set<keyof S>).some(key => effectStateFields.includes(key as string))
        && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
      ) {
        setState(stateRefByProxyHandle(new Map(Object.entries(nextState)), innerUseStateMapSet as Set<keyof S>));
      }
    });
  } else {
    (innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>).forEach((
      _,
      storesKey,
      map,
    ) => {
      (map.get(storesKey) as Set<keyof S>).forEach(() => {
        // å°†viewå…³è”åˆ°æ¯ä¸€ä¸ªstoreå†…éƒ¨çš„storeStateRefSetï¼Œè¿›è¡Œæ•°æ®ç”Ÿå‘½å‘¨æœŸçš„åŒæ­¥
        viewConnectStoreSet.add(
          (
            (
              store[VIEW_CONNECT_STORE_KEY as keyof S] as StoreViewMapType<S>
            ).get("viewConnectStore") as StoreViewMapValue<S>["viewConnectStore"]
          )()
        );
      });
    });
    
    return store.subscribe((
      effectState,
      nextState,
      prevState,
    ) => {
      const effectStateFields = Object.keys(effectState);
      const innerUseStateSet = (
        innerUseStateMapSet as Map<keyof Stores<S>, Set<keyof S>>
      ).get(storesKeyTemp as keyof Stores<S>) as Set<keyof S>;
      
      if (
        // Compç»„ä»¶å†…éƒ¨ä½¿ç”¨åˆ°çš„æ•°æ®å±æ€§å­—æ®µæ•°ç»„ï¼Œæ”¾åœ¨è§¦å‘æ‰§è¡Œä¿æŒå†…éƒ¨å¼•ç”¨æ•°æ®æœ€æ–°åŒ–
        Array.from(innerUseStateSet).some(key => effectStateFields.includes(key as string))
        && (!equal || !equal({ props, state: nextState }, { props, state: prevState }))
      ) {
        setState(viewStoresStateUpdateHandle(state, innerUseStateSet, nextState, storesKeyTemp));
      }
    });
  }
}
